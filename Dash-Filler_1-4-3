# import packages
import ctypes
import datetime
import glob
import os
import tkinter as tk
import warnings
from collections import OrderedDict
from copy import deepcopy
from tkinter import *
from tkinter import Tk
from tkinter import filedialog
from tkinter.filedialog import askopenfilename
import numpy as np
import pandas as pd
import xlsxwriter
from PIL import ImageTk, Image
from itertools import islice
from math import floor
from plotnine import *
import statsmodels.tsa.statespace._filters
import statsmodels.tsa.statespace._filters._conventional
import statsmodels.tsa.statespace._filters._univariate
import statsmodels.tsa.statespace._filters._univariate_diffuse
import statsmodels.tsa.statespace._filters._inversions
import statsmodels.tsa.statespace._smoothers
import statsmodels.tsa.statespace._smoothers._conventional
import statsmodels.tsa.statespace._smoothers._univariate
import statsmodels.tsa.statespace._smoothers._univariate_diffuse
import statsmodels.tsa.statespace._smoothers._classical
import statsmodels.tsa.statespace._smoothers._alternative
# import statsmodels.__init__._version
import xlrd

# Pyinstaller Compiler Code
# pyinstaller --onefile --hidden-import=xlrd --add-data "logo-369x123.png;." --add-data "mc_icon.ico;." --add-data "jalogo.png;." Dash-Filler_1-4-3.py
# pyinstaller Dash-Filler_1-4-3.spec

"""
-----------------------
Loads Dictionary Index
----------------------
'Delivery',     key
'Source_ID',    0
'Plan_Date',    1
'Origin',       2
'Trans_Mode',   3 
'Destination',  4
'State',        5
'Pallets',      6 
'Gross_Wt',     7
'To_Fill',      8
'Prefill_%',    9
'DayInList',    10
-----------------------
Orders Dictionary Index
-----------------------
'Order_ID',     Key
'Source_ID',    0
'Plan_WK',      1
'Origin',       2
'Trans_Mode',   3
'Destination',  4
'State',        5
'Base_UoM',     6
'MSKU',         7
'SO',           8
'SO_Line',      9
'Unit_Wt',      10
'U_Pallet',     11
'Pallets',      12
-----------------------
"""
apptitle = 'Dash Filler 1.4.3'
plants = {'Destination': [1000, 1010, 1020, 1030, 1040, 1060, 1070, 2000, 2020, 2030, 2060, 2070, 2080, 4010, 4020,
                          4030, 4200, 5000, 5050, 6800, 6810, 6850, 6860, 6870, 6880, 6890, 6900],
          'State': ['CO', 'WI', 'OH', 'TX', 'VA', 'GA', 'CA', 'CO', 'OR', 'NJ', 'GA', 'TX', 'WI', 'WI', 'KY', 'KY',
                    'TN', 'WI', 'WI', 'INT', 'INT', 'INT', 'INT', 'INT', 'INT', 'INT', 'INT']}
plants = pd.DataFrame(data=plants)

plantsdict = {1000: ['GOLDEN BREWERY', 'CO', 'CENTRAL'],
              1010: ['MILWAUKEE BREWERY', 'WI', 'GREAT LAKES'],
              1020: ['TRENTON BREWERY', 'OH', 'GREAT LAKES'],
              1030: ['FORT WORTH BREWERY', 'TX', 'CENTRAL'],
              1040: ['SHENANDOAH BREWERY', 'VA', 'NORTHEAST'],
              1060: ['ALBANY BREWERY', 'GA', 'SOUTHEAST'],
              1070: ['IRWINDALE BREWERY', 'CA', 'PACIFIC'],
              2000: ['GOLDEN DC', 'CO', 'CENTRAL'],
              2020: ['PORTLAND DC', 'OR', 'PACIFIC'],
              2030: ['ELIZABETH DC', 'NJ', 'NORTHEAST'],
              2060: ['ALBANY DC', 'GA', 'SOUTHEAST'],
              2070: ['FORT WORTH DC', 'TX', 'CENTRAL'],
              2080: ['MILWAUKEE DC', 'WI', 'GREAT LAKES'],
              4010: ['EAU CLAIRE  MALETTO CO-PACKER', 'WI', 'GREAT LAKES'],
              4020: ['CINCINNATI CO-PACKING & WAREHOUSING', 'KY', 'GREAT LAKES'],
              4030: ['COVINGTON KELLER CO-PACKER', 'KY', 'GREAT LAKES'],
              4200: ['MEMPHIS BLUESCITY BREWERY CO-B', 'TN', 'SOUTHEAST'],
              5000: ['CHIP FALLS LEINENKUGEL BREWERY', 'WI', 'GREAT LAKES'],
              5050: ['MILWAUKEE 10TH STREET BREWERY', 'WI', 'GREAT LAKES'],
              6800: ['BACKUS Y JOHNSTON S.A.A.', 'Int', 'INTERNATIONAL'],
              6810: ['TYSKIE BROWARY', 'Int', 'INTERNATIONAL'],
              6850: ['BAVARIA S.A.', 'Int', 'INTERNATIONAL'],
              6860: ['GROLSCH BREWERY', 'Int', 'INTERNATIONAL'],
              6870: ['BIRRA PERONI', 'Int', 'INTERNATIONAL'],
              6880: ['CZECH REPUBLIC IMPORT', 'Int', 'INTERNATIONAL'],
              6890: ['CANADA MOLSON MONTREAL IMPORT', 'Int', 'INTERNATIONAL'],
              6900: ['CANADA MOLSON TORONTO IMPORT', 'Int', 'INTERNATIONAL']}


# ----- Define Functions


def take(n: int, iterable) -> dict:
    """Return first n items of the iterable as a list"""
    return dict(islice(iterable, n))


def createlist(r1: int, r2: int) -> list:
    return list(range(r1, r2 + 1))


def resource_path(relative_path):
    """Get absolute path to resource, works for dev and for PyInstaller"""
    base_path = getattr(sys, '_MEIPASS', os.path.dirname(os.path.abspath(__file__)))
    return os.path.join(base_path, relative_path)


def round_down(num: float, divisor) -> int:
    return num - (num % divisor)


def round_down_ten(num: int) -> int:
    return num - num % 10


def so_splitter(string: str) -> list:
    """Dynamically split requirement element string into sales order and line item numbers"""
    so_list = string.split('/')
    so_list = [int(so_list[0]), int(so_list[1])]
    return so_list


def msku_list_splitter(mskustring: str) -> list:
    """Dynamically split MSKU string into separate elements in list"""
    # split string by ; into separate elements
    msku_list = mskustring.split(';')
    # create new list
    msku_int_list = []
    # loop through list
    for m in msku_list:
        try:
            # convert MSKU to integer and add to list
            msku_int_list.append(int(m))
        except ValueError:
            # if unable to convert to integer -> set as 0 and add to list
            msku_int_list.append(0)
    # remove all 0s from list of MSKUs to remove from processing
    msku_int_list = [i for i in msku_int_list if i != 0]
    return msku_int_list


def os_split_fixer(string):
    """Separate and rejoin selected file path with correct operating system separator"""
    delimiters = '/', '\\'
    maxsplit = 0
    regexPattern = '|'.join(map(re.escape, delimiters))
    splits = re.split(regexPattern, string, maxsplit)
    splitlist = []
    for split in splits:
        splitlist.append(split + os.sep)

    path = ''.join(splitlist)
    splitpath = path[:-1]
    return splitpath


def no_labels(values):
    """Create a dynamically long list of blank values to remove tick marks from plot axes"""
    return [""] * len(values)


def target_graph(filled, avgadd, delfilled, savepath, today):
    """Create plot of weight to fill target by weight added"""
    plottitle = 'Weight Added - Average ' + str('{:,}'.format(avgadd)) + 'lbs (' + \
                str('{:.0%}'.format(delfilled)) + ' of Deliveries Filled)'
    plot = (ggplot(data=filled, mapping=aes(x='To_Fill', y='Wt_Added', size='Wt_Added'))
            + geom_point(alpha=0.45, color='#1496FF', show_legend=False)
            + geom_smooth(method='lm', se=True, span=.5, color='#1496FF', alpha=0.5, show_legend=False)
            + labs(x='Target Weight To Fill (Lbs)', y='Weight Added (Lbs)', title=plottitle)
            + geom_abline(intercept=0, slope=1, color='#FFB000', size=1, linetype='dashed')
            + theme_gray()
            + theme(
                plot_title=element_text(style='italic', size=12, color='#091F3F', ha='center', weight='light'),
                figure_size=(8, 4.944),
                legend_position=(.25, .75),
                legend_title=element_text(text='', style='oblique', size=10, color='#091F3F',
                                          ha='center', weight='light'),
                legend_title_align='right',
                legend_background=element_rect(color='', size=1, fill='none'),
                legend_box_background=element_rect(color='#091F3F', size=9, fill='none', weight='light'),
                axis_line_x=element_line(size=1, color='#091F3F'),
                axis_line_y=element_line(size=1, color='#091F3F'),
                axis_text_x=element_text(style='italic', size=8, color='#091F3F', ha='center', weight='light'),
                axis_text_y=element_text(style='italic', size=8, color='#091F3F', ha='right', weight='light'),
                axis_title_x=element_text(size=10, color='#091F3F', ha='center', weight='light'),
                axis_title_y=element_text(size=10, color='#091F3F', ha='center', weight='light')))
    png = 'Weight Added - ' + today + '.png'  # name file
    png = os.path.join(savepath, png)  # join file name to directory path
    png = os_split_fixer(png)  # correct operating system separators
    plot.save(png, height=6, width=8, verbose=False)  # save new file to directory
    return png


def targetdist_graph(data, wtadded, wtfrac, savepath, today):
    """Create plot of Weight distribution before and after processing compared to all fully utilized deliveries"""
    plottitle = 'Weight Distribution - ' + str('{:,}'.format(wtadded)) + 'lbs Filled (' + \
                '{:.0%}'.format(wtfrac) + ' of possible)'
    plot = (ggplot(data=data, mapping=aes(x='Weight', color='Category', fill='Category'))
            + geom_density(mapping=aes(x='Weight', y='stat(count)'), alpha=.2)
            + coord_cartesian(xlim=(20000, 55000))
            + labs(x='Weight (Lbs)', y='', title=plottitle)
            + scale_color_manual(values=['#091F3F', '#1496FF', '#FFB000'], limits=['Starting Weight',
                                                                                   'Ending Weight', 'Target Weight'])
            + scale_fill_manual(values=['#091F3F', '#1496FF', '#FFB000'], limits=['Starting Weight',
                                                                                  'Ending Weight', 'Target Weight'])
            + theme_gray()
            + theme(
                plot_title=element_text(style='italic', size=12, color='#091F3F', ha='center', weight='light'),
                figure_size=(8, 4.944),
                legend_position=(.23, .8),
                legend_title=element_text(text='', style='oblique', size=10, color='#091F3F', ha='center',
                                          weight='light'),
                legend_title_align='right',
                legend_background=element_rect(color='', size=1, fill='none'),
                legend_box_background=element_rect(color='#091F3F', size=9, fill='none', weight='light'),
                legend_direction='vertical',
                axis_line_x=element_line(size=1, color='#091F3F'),
                axis_line_y=element_line(size=1, color='#091F3F'),
                axis_text_x=element_text(text='', style='italic', size=8, color='#091F3F', ha='center', weight='light'),
                axis_text_y=element_text(style='italic', size=8, color='#091F3F', ha='right', weight='light'),
                axis_title_x=element_text(size=10, color='#091F3F', ha='center', weight='light'),
                axis_title_y=element_text(size=10, color='#091F3F', ha='center', weight='light')))
    png = 'Target Distribution - ' + today + '.png'  # name file
    png = os.path.join(savepath, png)  # join file name to directory path
    png = os_split_fixer(png)  # correct operating system separators
    plot.save(png, height=6, width=8, verbose=False)  # save new file to directory
    return png


def boxplot_graph(data, utarget, utargetchg, savepath, today):
    """Create box plot of delivery utilization before and after processing by ship date """
    plottitle = 'Utilization by Ship Date - ' + str('{:.0%}'.format(utarget)) + ' (+' \
                + str('{:.0%}'.format(utargetchg)) + ') at or above Target'
    plot = (ggplot(data=data, mapping=aes(x='Plan_Date', y='Utiliz', color='Type'))  # , size='Weight'
            + geom_boxplot(alpha=.5)
            + labs(x='Planned Ship Date', y='Utilization', title=plottitle)
            + geom_hline(yintercept=0.96, color='#FFB000', size=1)
            + scale_color_manual(values=['#091F3F', '#1496FF'], limits=['Starting Utilization', 'Ending Utilization'])
            + theme_gray()
            + theme(
                plot_title=element_text(style='italic', size=12, color='#091F3F', ha='center', weight='light'),
                figure_size=(8, 4.944),
                legend_position=(.25, .25),
                legend_title=element_text(text='', style='oblique', size=10, color='#091F3F', ha='center',
                                          weight='light'),
                legend_title_align='right',
                legend_background=element_rect(color='', size=1, fill='none'),
                legend_box_background=element_rect(color='#091F3F', size=9, fill='none', weight='light'),
                legend_direction='vertical',
                axis_line_x=element_line(size=1, color='#091F3F'),
                axis_line_y=element_line(size=1, color='#091F3F'),
                axis_text_x=element_text(text='', style='italic', size=8, color='#091F3F', ha='center', weight='light'),
                axis_text_y=element_text(style='italic', size=8, color='#091F3F', ha='right', weight='light'),
                axis_title_x=element_text(size=10, color='#091F3F', ha='center', weight='light'),
                axis_title_y=element_text(size=10, color='#091F3F', ha='center', weight='light')))
    png = 'Utilization by Date - ' + today + '.png'  # name file
    png = os.path.join(savepath, png)  # join file name to directory path
    png = os_split_fixer(png)  # correct operating system separators
    plot.save(png, height=6, width=8, verbose=False)  # save new file to directory
    return png


def stackedbar_plot(data, avgperfull, avgperfullchng, savepath, today):
    """Create plot of the weight breakout for each order between starting, added, and remainder"""
    plottitle = 'Weight Added by Order - ' + str('{:.0%}'.format(avgperfull)) + ' (+' + \
                str('{:.0%}'.format(avgperfullchng)) + ') Average Utilization'
    plot = (ggplot(data=data, mapping=aes(x='Order', y='Weight', color='Category', fill='Category'))
            + geom_bar(stat='identity', position='stack', alpha=1)
            + labs(x='Order', y='Weight (Lbs)', title=plottitle)
            + scale_color_manual(values=['#D8E0E4', '#1496FF', '#FFB000'], limits=['Starting Weight', 'Added Weight',
                                                                                   'Remainder'])  # BDC2C8
            + scale_fill_manual(values=['#D8E0E4', '#1496FF', '#FFB000'], limits=['Starting Weight', 'Added Weight',
                                                                                  'Remainder'])
            + theme_gray()
            + theme(
                plot_title=element_text(style='italic', size=12, color='#091F3F', ha='center', weight='light'),
                figure_size=(8, 4.944),
                legend_position=(.25, .3),
                legend_title=element_text(text='', style='oblique', size=10, color='#091F3F', ha='center',
                                          weight='light'),
                legend_title_align='right',
                legend_background=element_rect(color='', size=1, fill='none'),
                legend_box_background=element_rect(color='#091F3F', size=9, fill='none', weight='light'),
                legend_direction='vertical',
                axis_line_x=element_line(size=1, color='#091F3F'),
                axis_line_y=element_line(size=1, color='#091F3F'),
                axis_text_x=element_text(text='', style='italic', size=8, color='#091F3F', ha='center',
                                         weight='light'),
                axis_text_y=element_text(style='italic', size=8, color='#091F3F', ha='right', weight='light'),
                axis_title_x=element_text(size=10, color='#091F3F', ha='center', weight='light'),
                axis_title_y=element_text(size=10, color='#091F3F', ha='center', weight='light')))
    png = 'Weight Added by Order - ' + today + '.png'  # name file
    png = os.path.join(savepath, png)  # join file name to directory path
    png = os_split_fixer(png)  # correct operating system separators
    plot.save(png, height=6, width=8, verbose=False)  # save new file to directory
    return png


def get_concat_v_resize(im1, im2, resample=Image.BICUBIC, resize_big_image=True):
    if im1.width == im2.width:
        _im1 = im1
        _im2 = im2
    elif (((im1.width > im2.width) and resize_big_image) or
          ((im1.width < im2.width) and not resize_big_image)):
        _im1 = im1.resize((im2.width, int(im1.height * im2.width / im1.width)), resample=resample)
        _im2 = im2
    else:
        _im1 = im1
        _im2 = im2.resize((im1.width, int(im2.height * im1.width / im2.width)), resample=resample)
    dst = Image.new('RGB', (_im1.width, _im1.height + _im2.height))
    dst.paste(_im1, (0, 0))
    dst.paste(_im2, (0, _im1.height))
    return dst


def get_concat_h_resize(im1, im2, resample=Image.BICUBIC, resize_big_image=True):
    if im1.height == im2.height:
        _im1 = im1
        _im2 = im2
    elif (((im1.height > im2.height) and resize_big_image) or
          ((im1.height < im2.height) and not resize_big_image)):
        _im1 = im1.resize((int(im1.width * im2.height / im1.height), im2.height), resample=resample)
        _im2 = im2
    else:
        _im1 = im1
        _im2 = im2.resize((int(im2.width * im1.height / im2.height), im1.height), resample=resample)
    dst = Image.new('RGB', (_im1.width + _im2.width, _im1.height))
    dst.paste(_im1, (0, 0))
    dst.paste(_im2, (_im1.width, 0))
    return dst


def plot_finalizer(im1, im2, im3, im4, savepath, today):
    """Combines four plots into a 2x2 grid as a final dashboard"""
    jalogo = resource_path('jalogo.png')
    jalogo = Image.open(jalogo)
    topplot = get_concat_h_resize(im1, im2, resize_big_image=False)  # concat two pngs horizontally
    botplot = get_concat_h_resize(im3, im4, resize_big_image=False)  # concat two pngs horizontally
    fpicname = savepath + os.sep + 'Dash Filler Results - ' + today + '.png'  # name graph file of results
    png = os.path.join(savepath, fpicname)  # join file name to directory path
    png = os_split_fixer(png)  # correct operating system separators
    plot = get_concat_v_resize(topplot, botplot)  # concat both pngs vertically
    plot = get_concat_v_resize(plot, jalogo)  # concat both pngs vertically
    plot.save(png, verbose=False)  # save new file to directory
    Image.open(png).show()  # open the final plot result
    return


def weekcheck_limiter(projinv: list, plansdate, orderweek: int) -> list:
    """Check sales order week and order ship date to adjust projected inventory"""
    # create assign limit variable
    assign_limit = 999999999
    # create projected inventory week to adjust variable
    piweek_adj = 'no adjustment'
    # get week 1 sunday projected inventory
    week1sunproji = projinv[0]
    # get week 2 sunday projected inventory
    week2sunproji = projinv[1]
    # get current week (week +0)
    current_week = datetime.datetime.now().isocalendar()[1]
    # get plan week (week +1)
    plan_week = current_week + 1
    # convert plansdate string to datetime object
    plansdate = datetime.datetime.strptime(plansdate, '%m/%d/%Y')
    # get order ship week for a Delivery
    shipweek = plansdate.isocalendar()[1]
    # if sales order and delivery are both in week 1 or earlier
    # if (orderweek <= current_week and shipweek <= current_week or
    #         # if sales order is in week 1 and delivery is in week 2
    #         orderweek == current_week and shipweek == plan_week or
    #         # if sales order and delivery are both in week 2
    #         orderweek == plan_week and shipweek == plan_week):
    #     # inventory already accounted for in projected inventory -> no assign limit
    #     assign_limit = 999999999
    #     piweek_adj = 'no adjustment'
    # if sales order is in week 2 and delivery is in week 1 or earlier
    if orderweek == plan_week and shipweek <= current_week:
        # set assign limit to the week 1 projected inventory
        assign_limit = week1sunproji
        piweek_adj = 'week 1'
    # if sales order is past week 2 and delivery is in week 2
    elif orderweek > plan_week and shipweek == plan_week:
        # set assign limit to the week 2 projected inventory
        assign_limit = week2sunproji
        piweek_adj = 'week 2'
    # if sales order is past week 2 and delivery is in week 1
    elif orderweek > plan_week and shipweek == current_week:
        # set assign limit to the max of either week 1 or week 2 projected inventory
        assign_limit = max(projinv, default=0)
        piweek_adj = 'both'
    # create output list
    weekcheckerlist = [assign_limit, piweek_adj]
    return weekcheckerlist


def sto_fixer(inv_days: list, key: str, realinv: dict) -> list:
    """Offset daily inventory to reflect real availability from externally produced MSKUs"""
    # get production type from the last value in the list
    ptype = str(inv_days[-1])
    try:
        # if MSKU is produced internally -> just remove production type
        if ptype == 'Internal':
            inv_days.pop()  # remove production type from list
        # if MSKU is produced externally -> offset list by one day
        elif ptype == 'External':
            # inv_days = inv_days[:-2]  # remove last day of inventory and production type from list
            inv_days.pop()
            inv_days.pop()
            day1inv = next(iter(realinv.get(key, 0)))  # lookup plant-MSKU key in realinv dictionary for day1 inv
            # day1inv = day1invlist[0]
            inv_days.insert(0, day1inv)
    except (IndexError, TypeError):
        pass
    return inv_days


def pastfixer(inv_days: list) -> list:
    """Update daily inventory to reflect real availability from following days"""
    # reverse the list
    inv_days.reverse()
    # iterate through each value-list in reverse
    for index, day in enumerate(inv_days):
        # if inventory is negative set as 0
        if inv_days[index] < 0:
            inv_days[index] = 0
        # grab next index value
        iplus1 = index + 1
        try:
            # if previous day has higher inventory, reduce
            if inv_days[index] < inv_days[iplus1]:
                inv_days[iplus1] = inv_days[index]
        except IndexError:
            continue

    # reverse list to original direction
    inv_days.reverse()
    return inv_days


def futurefixer(days: list, units: int) -> list:
    """Update daily inventory levels after product has been assigned"""
    # calculate required loops
    day_rng = len(days)
    # loop through inventory list
    for x in range(0, day_rng):
        # subtract assigned units
        days[x] = days[x] - units
        # set as 0 if negative
        if days[x] < 0:
            days[x] = 0
    return days


def dynamicdayrange() -> [list, str, str]:
    """Set day range dynamically"""
    # get today's weekday number
    today_num = datetime.datetime.today().weekday()
    # standard complete day range list
    day_nums = {0: 'Wed', 1: 'Thu', 2: 'Fri', 3: 'Sat', 4: 'Sun', 5: 'Mon', 6: 'Tue',
                7: 'Wed', 8: 'Thu', 9: 'Fri', 10: 'Sat', 11: 'Sun'}
    # calculate loops to determine length of list
    daycount = len(day_nums) - today_num + 1
    # get today datetime object
    ifr_today = datetime.datetime.today()
    # get first day in range
    ifr_sdate = ifr_today + datetime.timedelta(days=2)
    # get last day in range
    ifr_edate = ifr_today + datetime.timedelta(days=daycount)
    # format as date mm-dd-yyyy
    ifr_sdate = ifr_sdate.strftime('%m/%d/%Y')
    ifr_edate = ifr_edate.strftime('%m/%d/%Y')
    # create new list
    day_list = []
    # create list of header names
    for x in range(2, daycount + 1):
        # create new string
        dtitle = ifr_today + datetime.timedelta(days=x)
        # format as date mm-dd-yyyy
        dtitle = dtitle.strftime('%m/%d/%Y')
        # add new string to list
        day_list.append(dtitle)

    return day_list, ifr_sdate, ifr_edate


def ewm_dynamicdayrange() -> [list, str, str]:
    """Set day range dynamically for processing ewm distributed loads"""
    # get today's weekday number
    today_num = datetime.datetime.today().weekday()
    # standard complete day range list
    day_nums = {0: 'Wed', 1: 'Thu', 2: 'Fri', 3: 'Sat', 4: 'Sun', 5: 'Mon', 6: 'Tue',
                7: 'Wed', 8: 'Thu', 9: 'Fri', 10: 'Sat', 11: 'Sun'}
    # calculate loops to determine length of list
    daycount = len(day_nums) - today_num + 1
    # get today datetime object
    ifr_today = datetime.datetime.today()
    # get first day in range
    ifr_sdate = ifr_today
    # get last day in range
    ifr_edate = ifr_today + datetime.timedelta(days=daycount)
    # format as date mm-dd-yyyy
    ifr_sdate = ifr_sdate.strftime('%m/%d/%Y')
    ifr_edate = ifr_edate.strftime('%m/%d/%Y')
    # create new list
    day_list = []
    # create list of header names
    for x in range(0, daycount + 1):
        # create new string
        dtitle = ifr_today + datetime.timedelta(days=x)
        # format as date mm-dd-yyyy
        dtitle = dtitle.strftime('%m/%d/%Y')
        # add new string to list
        day_list.append(dtitle)

    return day_list, ifr_sdate, ifr_edate


def dynamic_pi_sundays() -> list:
    """Find Sundays in dynamic dayrange list"""
    # get today's weekday number
    today_num = datetime.datetime.today().weekday()
    pisun1 = 7 - today_num - 2  # -2 to account for 2 day offset
    pisun2 = pisun1 + 7
    # adjust first Sunday date to first inventory day if today is sunday
    if pisun1 < 0:
        pisun1 = 1
    return pisun1, pisun2


def ewm_dynamic_pi_sundays() -> list:
    """Find Sundays in dynamic dayrange list"""
    # get today's weekday number
    today_num = datetime.datetime.today().weekday()
    ewm_pisun1 = 7 - today_num
    ewm_pisun2 = ewm_pisun1 + 7
    # adjust first Sunday date to first inventory day if today is sunday
    if ewm_pisun1 < 0:
        ewm_pisun2 = 1
    return ewm_pisun1, ewm_pisun2


def assign(target: int, p_wt: float, t_plt: float, u_plt: int, atp: int, pi_limit: int) -> list:
    """Calculates how many pallets of unplanned demand can be assigned to the delivery"""
    # check how many pallets can be assigned
    try:
        # pallets assigned = wt to fill / pallet wt rounded down to integer
        p_assigned = floor(target / p_wt)
        # units assigned = pallets you can assign * units per pallet
        u_assigned = p_assigned * u_plt
        # unit weight = pallet wt / units per pallet
        u_wt = p_wt / u_plt
        # units available = min between avail pallets * units/pallet or inv available or proj inv limit
        u_avail = round_down(min((t_plt * u_plt), atp, pi_limit), u_plt)
    # if pallet wt == 0
    except ZeroDivisionError:
        p_assigned = 0
        u_assigned = 0
    # if one pallet weighs is greater than target or units per pallet greater than available -> make no assignment
    if p_wt > target or p_assigned == 0 or u_plt > atp:
        # do not adjust target weight
        n_target = target
        # do not adjust atp quantity
        return [0, 0, n_target]
    # if units assigned is greater than units available -> assign available
    elif u_assigned > u_avail:
        # calculate weight of units assigned used to fill
        filled = u_avail * u_wt
        # subtract weight assigned to calculate new target
        n_target = target - filled
        # calculate pallets assigned
        t_plt = floor(u_avail / u_plt)
        # assign all available
        return [t_plt, filled, n_target]
    # if amount needed to fill is less than pallets available and atp units available
    else:
        # calculate weight to assign
        filled = p_assigned * p_wt
        # subtract weight assigned to calculate new target
        n_target = target - filled
        # assign the calculated number of pallets
        t_plt = p_assigned
        return [t_plt, filled, n_target]


def xlsxknitter() -> str:
    # get today as mm-dd-yyyy
    date = datetime.datetime.today().strftime("%m-%d-%Y")
    # file select dialogue
    Tk().withdraw()  # prevent root window
    fpath = filedialog.askdirectory(title='Select the Inventory Flow Report folder')
    # create list of each xlsx file in fpath folder
    filenames = glob.glob(fpath + "/*.xlsx")
    # create empty dataframe
    dfs = []
    # loop through list of files
    for filename in filenames:
        # read each excel file to a new dataframe
        df = pd.read_excel(filename, index_col=None, header=0)
        # append new dataframe to dfs dataframe
        dfs.append(df)

    # concatenate dfs into a combined dataframe
    frame = pd.concat(dfs, axis=0, ignore_index=True)
    # file destination select dialogue
    Tk().withdraw()  # prevent root window
    spath = filedialog.askdirectory(title='Select the Inventory Flow Report save destination')
    # create file name
    ifrfile = spath + "\\Inventory Flow Report - Knitted - " + date + ".xlsx"
    # create excel writer
    writer = pd.ExcelWriter(ifrfile, engine='xlsxwriter')
    # Convert the dataframe to an XlsxWriter Excel object.
    frame.to_excel(writer, sheet_name='Sheet1', index=False)
    # Close the Pandas Excel writer and output the Excel file.
    writer.save()
    # pop up message box alert
    ctypes.windll.user32.MessageBoxW(0, 'Your new Inventory Flow Report has been created successfully!',
                                     'Knitter Completed', 0)
    return ifrfile


def reqxlsxknitter() -> str:
    # get today as mm-dd-yyyy
    date = datetime.datetime.today().strftime("%m-%d-%Y")
    # file select dialogue
    Tk().withdraw()  # prevent root window
    fpath = filedialog.askdirectory(title='Select the Requirements View Reports folder')
    # create list of each xlsx file in fpath folder
    filenames = glob.glob(fpath + "/*.xlsx")
    # create empty dataframe
    dfs = []
    # loop through list of files
    for filename in filenames:
        # read each excel file to a new dataframe
        df = pd.read_excel(filename, index_col=None, header=0)
        # append new dataframe to dfs dataframe
        dfs.append(df)

    # concatenate dfs into a combined dataframe
    frame = pd.concat(dfs, axis=0, ignore_index=True)
    # file destination select dialogue
    Tk().withdraw()  # prevent root window
    spath = filedialog.askdirectory(title='Select the Requirements View Report save destination')
    # create file name
    ifrfile = spath + "\\Requirements View - Knitted - " + date + ".xlsx"
    # create excel writer
    writer = pd.ExcelWriter(ifrfile, engine='xlsxwriter')
    # Convert the dataframe to an XlsxWriter Excel object.
    frame.to_excel(writer, sheet_name='Sheet1', index=False)
    # Close the Pandas Excel writer and output the Excel file.
    writer.save()
    # pop up message box alert
    ctypes.windll.user32.MessageBoxW(0, 'Your new Requirements View Report has been created successfully!',
                                     'Knitter Completed', 0)
    return ifrfile


def import_gatp(gatpfile: str, mit: str) -> [dict, dict]:
    """Get source data and create gATP dictionary from today+2 to end of plan week"""
    # start timer
    begin_time = datetime.datetime.now()
    print(f"  Importing inventory data to dictionary")
    print(f"  Start time:                        {begin_time}")
    # turn off warnings
    warnings.simplefilter('ignore')
    # read excel to dataframe
    df = pd.read_excel(gatpfile)
    # rename columns by position
    df = df.rename(columns={df.columns[0]: 'MSKU', df.columns[1]: 'Plant', df.columns[2]: 'Desc',
                            df.columns[3]: 'Drop1', df.columns[4]: 'Drop2', df.columns[5]: 'ATP'})
    # drop blank column and UoM column
    df.drop(['Drop1', 'Drop2'], axis=1, inplace=True)
    # create key column
    df['ATP_ID'] = df.agg('{0[Plant]}-{0[MSKU]}'.format, axis=1)
    # delete unwanted columns
    df.drop(['Plant', 'MSKU'], axis=1, inplace=True)
    # get list of headers in dataframe
    dfcolsfixed = df.columns.tolist()
    # reindex ATP_ID from last to first in the list
    dfcolsfixed = dfcolsfixed[-1:] + dfcolsfixed[:-1]
    # delete last column from dataframe
    dfcolsfixed.pop()
    # reindex dataframe headers from list
    df = df[dfcolsfixed]
    # create new dataframe where desc == inventory
    dfinv = df[df['Desc'] == 'Inventory']
    # reindex columns
    dfinv = dfinv[['ATP_ID', 'ATP']]
    # create new dataframe where desc == outbound demand
    dfout = df[df['Desc'] == 'Outbound Demand']
    # rename columns by position
    dfout = dfout.rename(columns={df.columns[3]: 'Outbounds'})
    dfout = dfout[['ATP_ID', 'Outbounds']]
    # merge starting inventory and day 1 outbound dataframes
    dfrealinv = pd.merge(dfinv, dfout, how='inner', on='ATP_ID')
    # create new calculated column
    dfrealinv['Day1_Inv'] = dfrealinv['ATP'] - dfrealinv['Outbounds']
    # reindex dataframe
    dfrealinv = dfrealinv[['ATP_ID', 'Day1_Inv']]
    # convert real inventory dataframe to dictionary
    real_invdict = dfrealinv.set_index('ATP_ID').T.to_dict('list')
    # only keep rows where Desc == 'Cumul. ATP Qty' or Desc == 'Proj. Inventory' or Desc == 'Avail. Qty.(C)'
    df = df[(df['Desc'] == 'Cumul. ATP Qty') | (df['Desc'] == 'Proj. Inventory') | (df['Desc'] == 'Avail. Qty.(C)')]
    # create list for ATP_IDs to delete
    pos_atp_ids = []
    # create list of ATP_IDs with positive ATP to keep in dataframe
    for index, row in df.iterrows():
        if row['ATP'] < 0 and row['Desc'] == 'Cumul. ATP Qty':
            pos_atp_ids.append(row['ATP_ID'])

    # get Sunday week 1 and 2 column index in dataframe
    dynamicpisundayslist = dynamic_pi_sundays()
    piwk1sunday = dynamicpisundayslist[0]  # projected inventory sunday week 1 column index
    piwk2sunday = dynamicpisundayslist[1]  # projected inventory sunday week 2 column index
    # make new dataframe with Desc == 'Proj. Inventory' values
    pi = df[df['Desc'] == 'Proj. Inventory']
    # delete unwanted columns
    pi.drop(['Desc', 'ATP'], axis=1, inplace=True)
    # get date range list
    pidays_vars = dynamicdayrange()
    pidaylist = pidays_vars[0]
    # add ATP_ID to front of daylist
    pidaylist.insert(0, 'ATP_ID')
    # rename dataframe headers from list
    pi.columns = pidaylist
    # keep rows if ATP_ID is in list
    pi = pi[~pi.ATP_ID.isin(pos_atp_ids)]
    # reset index with Delivery as first column
    pi.reset_index(drop=True, inplace=True)
    # convert projected inventory dataframe to dictionary
    pregatps = pi.set_index('ATP_ID').T.to_dict('list')
    # iterate through dictionary by key
    for key, pregatp in pregatps.items():
        # offset inventory levels if externally produced and remove production type from end of list
        pastfixer(pregatp)

    # convert dictionary back to dataframe
    pi = pd.DataFrame.from_dict(pregatps, orient='index')
    # reset index with Delivery as first column
    pi.reset_index(drop=False, inplace=True)
    # rename dataframe headers from list
    pi.columns = pidaylist
    # rename columns by position
    pi = pi.rename(columns={pi.columns[piwk1sunday]: 'Week1', pi.columns[piwk2sunday]: 'Week2'})
    # reindex columns
    pi = pi[['ATP_ID', 'Week1', 'Week2']]
    # convert dataframe to dictionary
    proji = pi.set_index('ATP_ID').T.to_dict('list')
    # only keep row if Desc == 'Avail. Qty.(C)'
    df = df[df['Desc'] == 'Avail. Qty.(C)']
    # delete unwanted columns
    df.drop(['Desc', 'ATP'], axis=1, inplace=True)
    # get date range list
    days_vars = dynamicdayrange()
    daylist = days_vars[0]
    # add ATP_ID to front of daylist
    daylist.insert(0, 'ATP_ID')
    # rename dataframe headers from list
    df.columns = daylist
    # keep rows if ATP_ID is in list
    df = df[~df.ATP_ID.isin(pos_atp_ids)]
    # reset index with Delivery as first column
    df.reset_index(drop=True, inplace=True)
    # read excel to dataframe
    mit = pd.read_excel(mit, sheet_name='Master Data')
    # reindex columns
    mit = mit[['ID', 'Production Type']]
    # format the data frame
    mit = mit.rename(columns={'ID': 'ATP_ID', 'Production Type': 'Prod_Type'})
    # merge MSKU data into requirements view
    df = pd.merge(df, mit, how='inner', on='ATP_ID')
    # convert data frame to dictionary
    gatps = df.set_index('ATP_ID').T.to_dict('list')
    # iterate through dictionary by key
    for key, gatp in gatps.items():
        # offset inventory levels if externally produced and remove production type from end of list
        sto_fixer(gatp, key, real_invdict)
    # iterate through dictionary by key
    for key, gatp in gatps.items():
        # set inventory to real availability
        pastfixer(gatp)

    # turn warnings back on
    warnings.simplefilter('default')
    # print execution time
    end_time = datetime.datetime.now()
    gatp_time = end_time - begin_time
    print(f"  End time:                          {end_time}")
    print(f"  gATP Time:                         {gatp_time}")
    print(f"  Dictionary created successfully")
    return gatps, proji


def ewm_import_gatp(gatpfile: str, mit: str) -> [dict, dict]:
    """Get source data and create gATP dictionary from current day to end of plan week"""
    # start timer
    begin_time = datetime.datetime.now()
    print(f"  Importing inventory data to dictionary")
    print(f"  Start time:                        {begin_time}")
    # turn off warnings
    warnings.simplefilter('ignore')
    # read excel to dataframe
    df = pd.read_excel(gatpfile)
    # rename columns by position
    df = df.rename(columns={df.columns[0]: 'MSKU', df.columns[1]: 'Plant', df.columns[2]: 'Desc',
                            df.columns[3]: 'Drop1', df.columns[4]: 'Drop2', df.columns[5]: 'ATP'})
    # drop blank column and UoM column
    df.drop(['Drop1', 'Drop2'], axis=1, inplace=True)
    # create key column
    df['ATP_ID'] = df.agg('{0[Plant]}-{0[MSKU]}'.format, axis=1)
    # delete unwanted columns
    df.drop(['Plant', 'MSKU'], axis=1, inplace=True)
    # get list of headers in dataframe
    dfcolsfixed = df.columns.tolist()
    # reindex ATP_ID from last to first in the list
    dfcolsfixed = dfcolsfixed[-1:] + dfcolsfixed[:-1]
    # delete last column from dataframe
    dfcolsfixed.pop()
    # reindex dataframe headers from list
    df = df[dfcolsfixed]
    # create new dataframe where desc == inventory
    dfinv = df[df['Desc'] == 'Inventory']
    # reindex columns
    dfinv = dfinv[['ATP_ID', 'ATP']]
    # create new dataframe where desc == outbound demand
    dfout = df[df['Desc'] == 'Outbound Demand']
    # rename columns by position
    dfout = dfout.rename(columns={df.columns[3]: 'Outbounds'})
    dfout = dfout[['ATP_ID', 'Outbounds']]
    # merge starting inventory and day 1 outbound dataframes
    dfrealinv = pd.merge(dfinv, dfout, how='inner', on='ATP_ID')
    # create new calculated column
    dfrealinv['Day1_Inv'] = dfrealinv['ATP'] - dfrealinv['Outbounds']
    # reindex dataframe
    dfrealinv = dfrealinv[['ATP_ID', 'Day1_Inv']]
    # convert real inventory dataframe to dictionary
    real_invdict = dfrealinv.set_index('ATP_ID').T.to_dict('list')
    # only keep rows where Desc == 'Cumul. ATP Qty' or Desc == 'Proj. Inventory' or Desc == 'Avail. Qty.(C)'
    df = df[(df['Desc'] == 'Cumul. ATP Qty') | (df['Desc'] == 'Proj. Inventory') | (df['Desc'] == 'Avail. Qty.(C)')]
    # create list for ATP_IDs to delete
    pos_atp_ids = []
    # create list of ATP_IDs with positive ATP to keep in dataframe
    for index, row in df.iterrows():
        if row['ATP'] < 0 and row['Desc'] == 'Cumul. ATP Qty':
            pos_atp_ids.append(row['ATP_ID'])

    # get Sunday week 1 and 2 column index in dataframe
    dynamicpisundayslist = ewm_dynamic_pi_sundays()
    piwk1sunday = dynamicpisundayslist[0]  # projected inventory sunday week 1 column index
    piwk2sunday = dynamicpisundayslist[1]  # projected inventory sunday week 2 column index
    # make new dataframe with Desc == 'Proj. Inventory' values
    pi = df[df['Desc'] == 'Proj. Inventory']
    # delete unwanted columns
    pi.drop(['Desc', 'ATP'], axis=1, inplace=True)
    # get date range list
    pidays_vars = ewm_dynamicdayrange()
    pidaylist = pidays_vars[0]
    # add ATP_ID to front of daylist
    pidaylist.insert(0, 'ATP_ID')
    # rename dataframe headers from list
    pi.columns = pidaylist
    # keep rows if ATP_ID is in list
    pi = pi[~pi.ATP_ID.isin(pos_atp_ids)]
    # reset index with Delivery as first column
    pi.reset_index(drop=True, inplace=True)
    # convert projected inventory dataframe to dictionary
    pregatps = pi.set_index('ATP_ID').T.to_dict('list')
    # iterate through dictionary by key
    for key, pregatp in pregatps.items():
        # offset inventory levels if externally produced and remove production type from end of list
        pastfixer(pregatp)

    # convert dictionary back to dataframe
    pi = pd.DataFrame.from_dict(pregatps, orient='index')
    # reset index with Delivery as first column
    pi.reset_index(drop=False, inplace=True)
    # rename dataframe headers from list
    pi.columns = pidaylist
    # rename columns by position
    pi = pi.rename(columns={pi.columns[piwk1sunday]: 'Week1', pi.columns[piwk2sunday]: 'Week2'})
    # reindex columns
    pi = pi[['ATP_ID', 'Week1', 'Week2']]
    # convert dataframe to dictionary
    proji = pi.set_index('ATP_ID').T.to_dict('list')
    # only keep row if Desc == 'Avail. Qty.(C)'
    df = df[df['Desc'] == 'Avail. Qty.(C)']
    # delete unwanted columns
    df.drop(['Desc', 'ATP'], axis=1, inplace=True)
    # get date range list
    days_vars = ewm_dynamicdayrange()
    daylist = days_vars[0]
    # add ATP_ID to front of daylist
    daylist.insert(0, 'ATP_ID')
    # rename dataframe headers from list
    df.columns = daylist
    # keep rows if ATP_ID is in list
    df = df[~df.ATP_ID.isin(pos_atp_ids)]
    # reset index with Delivery as first column
    df.reset_index(drop=True, inplace=True)
    # read excel to dataframe
    mit = pd.read_excel(mit, sheet_name='Master Data')
    # reindex columns
    mit = mit[['ID', 'Production Type']]
    # format the data frame
    mit = mit.rename(columns={'ID': 'ATP_ID', 'Production Type': 'Prod_Type'})
    # merge MSKU data into requirements view
    df = pd.merge(df, mit, how='inner', on='ATP_ID')
    # convert data frame to dictionary
    gatps = df.set_index('ATP_ID').T.to_dict('list')
    # iterate through dictionary by key
    for key, gatp in gatps.items():
        # offset inventory levels if externally produced and remove production type from end of list
        sto_fixer(gatp, key, real_invdict)
    # iterate through dictionary by key
    for key, gatp in gatps.items():
        # set inventory to real availability
        pastfixer(gatp)

    # turn warnings back on
    warnings.simplefilter('default')
    # print execution time
    end_time = datetime.datetime.now()
    gatp_time = end_time - begin_time
    print(f"  End time:                          {end_time}")
    print(f"  gATP Time:                         {gatp_time}")
    print(f"  Dictionary created successfully")
    return gatps, proji


def prep_lwf_data(lwvrfile: str, dunnage):
    """Prepare load weight filler data into dataframe"""
    # turn off warnings
    warnings.simplefilter('ignore')
    delength = 9
    # read excel to dataframe
    df = pd.read_excel(lwvrfile, sheet_name='All')
    # rename columns
    df = df.rename(columns={'Delivery Number': 'Delivery', 'Planned Load End Wk Nbr': 'Plan_WK',
                            'Planned Load End Date': 'Plan_Date', 'Origin Plant': 'Origin',
                            'Dest Location Number': 'Destination', 'Dest Region': 'State',
                            'Transportation Mode Description': 'Trans_Mode',
                            'Distributed to EWM': 'Dist_to_EWM',
                            'Multiple Deliveries on the Shipment': 'Multi_Delivery',
                            'Total Pallets on Freight Order': 'Pallets',
                            'Resource Max Weight': 'Res_Max_Wt',
                            'Resource Max Weight Status': 'Res_Max_Wt_Status',
                            'Gross Wt LBS (FH)': 'Gross_Wt',
                            'Total Weight (Product Dependent Dunnage Calc)': 'Total_Weight'})
    # reindex dataframe
    df = df[['Delivery', 'Plan_WK', 'Plan_Date', 'Origin', 'Destination', 'State', 'Trans_Mode', 'Dist_to_EWM',
             'Multi_Delivery', 'Pallets', 'Res_Max_Wt', 'Res_Max_Wt_Status', 'Gross_Wt', 'Total_Weight']]
    # filling all missing values in dataframe with 0
    df = df.fillna(0)
    # drop rows where Trans_Mode == Sea
    df = df[df.Trans_Mode != 'Sea']
    # drop rows where Trans_Mode == 0
    df = df[df.Trans_Mode != 0]
    # drop row if Destination is an export code (Destination starts with 'US')
    df = df[df['Destination'].apply(lambda x: str(x)[:2] != 'US')]
    # replace column values with replacements
    df.loc[df.Trans_Mode == "Intermodal", "Trans_Mode"] = "Intm"
    # fill Res_Max_Wt with 43000 if 'Tentative' & Res_Max_Wt == 0 & ('Road' or 'Intm')
    df['Res_Max_Wt'] = np.where((df['Res_Max_Wt_Status'] == 'Tentative') & (df['Res_Max_Wt'] == 0) &
                                ((df['Trans_Mode'] == 'Road') | (df['Trans_Mode'] == 'Intm')), 43000, df['Res_Max_Wt'])
    # fill Res_Max_Wt with 168000 if 'Tentative' & Res_Max_Wt == 0 & Trans_Mode == 'Rail'
    df['Res_Max_Wt'] = np.where((df['Res_Max_Wt_Status'] == 'Tentative') & (df['Trans_Mode'] == 'Rail')
                                & (df['Res_Max_Wt'] == 0), 168000, df['Res_Max_Wt'])
    # fill Res_Max_Wt with 43000 if 'Final' & Res_Max_Wt == 0 & ('Road' or 'Intm')
    df['Res_Max_Wt'] = np.where((df['Res_Max_Wt_Status'] == 'Final') & (df['Res_Max_Wt'] == 0) &
                                ((df['Trans_Mode'] == 'Road') | (df['Trans_Mode'] == 'Intm')), 43000, df['Res_Max_Wt'])
    # drop rows where Resource Max Weight == 0
    df = df[df.Res_Max_Wt != 0]
    # only include rows where Delivery length equals 9 (remove incorrectly made deliveries)
    df = df[df['Delivery'].apply(lambda x: len(str(x)) >= delength)]
    # drop if Delivery is multi-stop
    df.drop(df[df['Multi_Delivery'] == 'X'].index, inplace=True)
    # drop if Delivery is distributed to EWM -> locked for processing
    df.drop(df[df['Dist_to_EWM'] == 'X'].index, inplace=True)
    # insert calculated field
    df['To_Fill'] = df['Res_Max_Wt'] - dunnage - df['Gross_Wt']
    # drop if Delivery doesn't need to be filled (drop if delivery is overweight)
    df.drop(df[df['To_Fill'] <= 0].index, inplace=True)
    # drop Plan_Date == 0 from data frame
    df = df[df.Plan_Date != 0]
    # calculate day range window
    day_window = dynamicdayrange()
    dayrange = day_window[0]
    # get start and end date in day window
    s_day_win = day_window[1]
    e_day_win = day_window[2]
    # convert to datetime with format mm/dd/yyyy
    s_day_win = datetime.datetime.strptime(s_day_win, '%m/%d/%Y')
    e_day_win = datetime.datetime.strptime(e_day_win, '%m/%d/%Y')
    # make new datetime column
    df['Check_Date'] = pd.to_datetime(df.Plan_Date)
    # create boolean column if Check_Date is within day window
    df['Date_Inc'] = np.where((df['Check_Date'] >= s_day_win) & (df['Check_Date'] <= e_day_win), 1, 0)
    # drop everything except Date_Inc == 1 from data frame
    df = df[df.Date_Inc == 1]
    # filling missing values
    df = df.fillna(0)
    # drop Origin == 0 from data frame
    df = df[df.Origin != 0]
    # format data frame columns
    df = df.astype({"Delivery": int, "Origin": int, "Pallets": int,
                    "Gross_Wt": float, "To_Fill": float, 'Destination': int})
    # create new columns
    df['Source_ID'] = df.agg('{0[Origin]}-{0[Destination]}'.format, axis=1)
    df['Prefill_%'] = df['Gross_Wt'] / (df['Gross_Wt'] + df['To_Fill'])
    # format data frame column
    df['Prefill_%'] = df['Prefill_%'].astype(float)
    # format 'Plan_Date' column as datetime
    df['Plan_Date'] = pd.to_datetime(df.Plan_Date)
    # format 'Plan_Date' column as mm/dd/yyyy
    df['Plan_Date'] = df['Plan_Date'].dt.strftime('%m/%d/%Y')
    # create list of Plan_Date values
    plandatelist = df['Plan_Date'].tolist()
    # create blank list for plan date positions
    dayinlist = []
    # loop through plan date list
    for i in plandatelist:
        # calc plan date position in list
        datepos = dayrange.index(i) + 1
        # add plan date position to list
        dayinlist.append(datepos)

    # create new series equal to list
    df['DayInList'] = dayinlist
    # delete all 0 values in Delivery column
    df = df[df.Delivery != 0]
    # reindex columns
    df = df[['Delivery', 'Source_ID', 'Plan_Date', 'Origin', 'Trans_Mode',
             'Destination', 'State', 'Pallets', 'Gross_Wt', 'To_Fill', 'Prefill_%', 'DayInList']]
    # sort Deliveries to review by plan date, then starting utilization, then oldest to newest
    df = df.sort_values(by=['Plan_Date', 'Prefill_%', 'Delivery'], ascending=[True, True, True])
    return df


def import_lwvr(lwvrfile: str, dunnage) -> dict:
    """Get source data and create loads Dictionary"""
    # start timer
    begin_time = datetime.datetime.now()
    print(f"  Importing load data to dictionary")
    print(f"  Start time:                        {begin_time}")
    print(f"  Dunnage set to:                    {dunnage}")
    df = prep_lwf_data(lwvrfile, dunnage)
    # convert data frame to dictionary
    loads = df.set_index('Delivery').T.to_dict('list')
    # turn warnings back on
    warnings.simplefilter('default')
    # print execution time
    end_time = datetime.datetime.now()
    lwvr_time = end_time - begin_time
    print(f"  End time:                          {end_time}")
    print(f"  LWVR time:                         {lwvr_time}")
    print(f"  Dictionary created successfully")
    return loads


def ewm_import_lwvr(lwvrfile: str, dunnage) -> dict:
    """Get source data and create EWM loads Dictionary"""
    # start timer
    begin_time = datetime.datetime.now()
    print(f"  Importing load data to dictionary")
    print(f"  Start time:                        {begin_time}")
    print(f"  Dunnage set to:                    {dunnage}")
    # turn off warnings
    warnings.simplefilter('ignore')
    delength = 9
    # read excel to dataframe
    df = pd.read_excel(lwvrfile, sheet_name='All')
    # rename columns
    df = df.rename(columns={'Delivery Number': 'Delivery', 'Planned Load End Wk Nbr': 'Plan_WK',
                            'Planned Load End Date': 'Plan_Date', 'Origin Plant': 'Origin',
                            'Dest Location Number': 'Destination', 'Dest Region': 'State',
                            'Transportation Mode Description': 'Trans_Mode',
                            'Distributed to EWM': 'Dist_to_EWM',
                            'Multiple Deliveries on the Shipment': 'Multi_Delivery',
                            'Total Pallets on Freight Order': 'Pallets',
                            'Resource Max Weight': 'Res_Max_Wt',
                            'Resource Max Weight Status': 'Res_Max_Wt_Status',
                            'Gross Wt LBS (FH)': 'Gross_Wt',
                            'Total Weight (Product Dependent Dunnage Calc)': 'Total_Weight'})
    # reindex dataframe
    df = df[['Delivery', 'Plan_WK', 'Plan_Date', 'Origin', 'Destination', 'State', 'Trans_Mode', 'Dist_to_EWM',
             'Multi_Delivery', 'Pallets', 'Res_Max_Wt', 'Res_Max_Wt_Status', 'Gross_Wt', 'Total_Weight']]
    # filling all missing values in dataframe with 0
    df = df.fillna(0)
    # drop rows where Trans_Mode == Sea
    df = df[df.Trans_Mode != 'Sea']
    # drop rows where Trans_Mode == 0
    df = df[df.Trans_Mode != 0]
    # drop row if Destination is an export code (Destination starts with 'US')
    df = df[df['Destination'].apply(lambda x: str(x)[:2] != 'US')]
    # replace column values with replacements
    df.loc[df.Trans_Mode == "Intermodal", "Trans_Mode"] = "Intm"
    # fill Res_Max_Wt with 43000 if 'Tentative' & Res_Max_Wt == 0 & ('Road' or 'Intm')
    df['Res_Max_Wt'] = np.where((df['Res_Max_Wt_Status'] == 'Tentative') & (df['Res_Max_Wt'] == 0) &
                                ((df['Trans_Mode'] == 'Road') | (df['Trans_Mode'] == 'Intm')), 43000, df['Res_Max_Wt'])
    # fill Res_Max_Wt with 168000 if 'Tentative' & Res_Max_Wt == 0 & Trans_Mode == 'Rail'
    df['Res_Max_Wt'] = np.where((df['Res_Max_Wt_Status'] == 'Tentative') & (df['Trans_Mode'] == 'Rail')
                                & (df['Res_Max_Wt'] == 0), 168000, df['Res_Max_Wt'])
    # fill Res_Max_Wt with 43000 if 'Final' & Res_Max_Wt == 0 & ('Road' or 'Intm')
    df['Res_Max_Wt'] = np.where((df['Res_Max_Wt_Status'] == 'Final') & (df['Res_Max_Wt'] == 0) &
                                ((df['Trans_Mode'] == 'Road') | (df['Trans_Mode'] == 'Intm')), 43000, df['Res_Max_Wt'])
    # drop rows where Resource Max Weight == 0
    df = df[df.Res_Max_Wt != 0]
    # only include rows where Delivery length equals 9 (remove incorrectly made deliveries)
    df = df[df['Delivery'].apply(lambda x: len(str(x)) >= delength)]
    # drop if Delivery is multi-stop
    df.drop(df[df['Multi_Delivery'] == 'X'].index, inplace=True)
    # only keep Deliveries that are distributed to EWM
    df = df[df.Dist_to_EWM == 'X']
    # insert calculated field
    df['To_Fill'] = df['Res_Max_Wt'] - dunnage - df['Gross_Wt']
    # drop if Delivery doesn't need to be filled (drop if delivery is overweight)
    df.drop(df[df['To_Fill'] <= 0].index, inplace=True)
    # drop Plan_Date == 0 from data frame
    df = df[df.Plan_Date != 0]
    # calculate day range window
    day_window = ewm_dynamicdayrange()
    dayrange = day_window[0]
    # get start and end date in day window
    s_day_win = day_window[1]
    e_day_win = day_window[2]
    # convert to datetime with format mm/dd/yyyy
    s_day_win = datetime.datetime.strptime(s_day_win, '%m/%d/%Y')
    e_day_win = datetime.datetime.strptime(e_day_win, '%m/%d/%Y')
    # make new datetime column
    df['Check_Date'] = pd.to_datetime(df.Plan_Date)
    # create boolean column if Check_Date is within day window
    df['Date_Inc'] = np.where((df['Check_Date'] >= s_day_win) & (df['Check_Date'] <= e_day_win), 1, 0)
    # drop everything except Date_Inc == 1 from data frame
    df = df[df.Date_Inc == 1]
    # filling missing values
    df = df.fillna(0)
    # drop Origin == 0 from data frame
    df = df[df.Origin != 0]
    # format data frame columns
    df = df.astype({"Delivery": int, "Origin": int, "Pallets": int,
                    "Gross_Wt": float, "To_Fill": float, 'Destination': int})
    # create new columns
    df['Source_ID'] = df.agg('{0[Origin]}-{0[Destination]}'.format, axis=1)
    df['Prefill_%'] = df['Gross_Wt'] / (df['Gross_Wt'] + df['To_Fill'])
    # format data frame column
    df['Prefill_%'] = df['Prefill_%'].astype(float)
    # format 'Plan_Date' column as datetime
    df['Plan_Date'] = pd.to_datetime(df.Plan_Date)
    # format 'Plan_Date' column as mm/dd/yyyy
    df['Plan_Date'] = df['Plan_Date'].dt.strftime('%m/%d/%Y')
    # create list of Plan_Date values
    plandatelist = df['Plan_Date'].tolist()
    # create blank list for plan date positions
    dayinlist = []
    # loop through plan date list
    for i in plandatelist:
        # calc plan date position in list
        datepos = dayrange.index(i) + 1
        # add plan date position to list
        dayinlist.append(datepos)

    # create new series equal to list
    df['DayInList'] = dayinlist
    # delete all 0 values in Delivery column
    df = df[df.Delivery != 0]
    # reindex columns
    df = df[['Delivery', 'Source_ID', 'Plan_Date', 'Origin', 'Trans_Mode',
             'Destination', 'State', 'Pallets', 'Gross_Wt', 'To_Fill', 'Prefill_%', 'DayInList']]
    # sort Deliveries to review by plan date, then starting utilization, then oldest to newest
    df = df.sort_values(by=['Plan_Date', 'Prefill_%', 'Delivery'], ascending=[True, True, True])
    # convert data frame to dictionary
    loads = df.set_index('Delivery').T.to_dict('list')
    # turn warnings back on
    warnings.simplefilter('default')
    # print execution time
    end_time = datetime.datetime.now()
    lwvr_time = end_time - begin_time
    print(f"  End time:                          {end_time}")
    print(f"  LWVR time:                         {lwvr_time}")
    print(f"  Dictionary created successfully")
    return loads


def prep_lane_wt(lwvrfile: str, dunnage: int):
    """Prepare and get minimum lane weight data into dataframe"""
    # turn off warnings
    warnings.simplefilter('ignore')
    delength = 9
    # read excel to dataframe
    df = pd.read_excel(lwvrfile, sheet_name='All')
    # rename columns
    df = df.rename(columns={'Delivery Number': 'Delivery', 'Planned Load End Wk Nbr': 'Plan_WK',
                            'Planned Load End Date': 'Plan_Date', 'Origin Plant': 'Origin',
                            'Dest Location Number': 'Destination', 'Dest Region': 'State',
                            'Transportation Mode Description': 'Trans_Mode',
                            'Distributed to EWM': 'Dist_to_EWM',
                            'Multiple Deliveries on the Shipment': 'Multi_Delivery',
                            'Total Pallets on Freight Order': 'Pallets',
                            'Resource Max Weight': 'Res_Max_Wt',
                            'Resource Max Weight Status': 'Res_Max_Wt_Status',
                            'Gross Wt LBS (FH)': 'Gross_Wt',
                            'Total Weight (Product Dependent Dunnage Calc)': 'Total_Weight'})
    # reindex dataframe
    df = df[['Delivery', 'Plan_WK', 'Plan_Date', 'Origin', 'Destination', 'State', 'Trans_Mode', 'Dist_to_EWM',
             'Multi_Delivery', 'Pallets', 'Res_Max_Wt', 'Res_Max_Wt_Status', 'Gross_Wt', 'Total_Weight']]
    # filling all missing values in dataframe with 0
    df = df.fillna(0)
    # drop rows where Trans_Mode == Sea
    df = df[df.Trans_Mode != 'Sea']
    # drop rows where Trans_Mode == 0
    df = df[df.Trans_Mode != 0]
    # drop row if Destination is an export code (Destination starts with 'US')
    df = df[df['Destination'].apply(lambda x: str(x)[:2] != 'US')]
    # replace column values with replacements
    df.loc[df.Trans_Mode == "Intermodal", "Trans_Mode"] = "Intm"
    # fill Res_Max_Wt with 43000 if 'Tentative' & Res_Max_Wt == 0 & ('Road' or 'Intm')
    df['Res_Max_Wt'] = np.where((df['Res_Max_Wt_Status'] == 'Tentative') & (df['Res_Max_Wt'] == 0) &
                                ((df['Trans_Mode'] == 'Road') | (df['Trans_Mode'] == 'Intm')), 43000,
                                df['Res_Max_Wt'])
    # fill Res_Max_Wt with 168000 if 'Tentative' & Res_Max_Wt == 0 & Trans_Mode == 'Rail'
    df['Res_Max_Wt'] = np.where((df['Res_Max_Wt_Status'] == 'Tentative') & (df['Trans_Mode'] == 'Rail')
                                & (df['Res_Max_Wt'] == 0), 168000, df['Res_Max_Wt'])
    # fill Res_Max_Wt with 43000 if 'Final' & Res_Max_Wt == 0 & ('Road' or 'Intm')
    df['Res_Max_Wt'] = np.where((df['Res_Max_Wt_Status'] == 'Final') & (df['Res_Max_Wt'] == 0) &
                                ((df['Trans_Mode'] == 'Road') | (df['Trans_Mode'] == 'Intm')), 43000,
                                df['Res_Max_Wt'])
    # drop rows where Resource Max Weight == 0
    df = df[df.Res_Max_Wt != 0]
    # only include rows where Delivery length equals 9 (remove incorrectly made deliveries)
    df = df[df['Delivery'].apply(lambda x: len(str(x)) >= delength)]
    # filling missing values
    df = df.fillna(0)
    # drop Origin == 0 from data frame
    df = df[df.Origin != 0]
    # format data frame columns
    df = df.astype({'Origin': int, 'Destination': int})
    # create new columns
    df['Source_ID'] = df.agg('{0[Origin]}-{0[Destination]}'.format, axis=1)
    # reindex dataframe
    df = df[['Source_ID', 'Res_Max_Wt']]
    # find lowest
    dfc = df.groupby('Source_ID')['Res_Max_Wt']
    # create new series with each source_ids lowest lane max weight
    df['Lane_Wt'] = dfc.transform('min')
    # subtract dunnage from lane wt to get ToFill value for all new loads
    df['Lane_Wt'] = df['Lane_Wt'] - dunnage
    # reindex dataframe
    df = df[['Source_ID', 'Lane_Wt']]
    # drop duplicate source_ids and shrink dataframe
    df = pd.DataFrame.drop_duplicates(df)
    return df


def lane_analyst(lwvrfile: str):
    """Get analyst responsible for each lane"""
    # turn off warnings
    warnings.simplefilter('ignore')
    delength = 9
    # read excel to dataframe
    df = pd.read_excel(lwvrfile, sheet_name='All')
    # rename columns
    df = df.rename(columns={'CSA/Planner': 'Analyst', 'Dest Location Number': 'Destination'})
    # reindex dataframe
    df = df[['Destination', 'Analyst']]
    # filling all missing values in dataframe with 0
    df = df.fillna(0)
    # only keep nonzero values for Destination
    df = df[df.Destination != 0]
    # drop row if Destination is an export code (Destination starts with 'US')
    df = df[df['Destination'].apply(lambda x: str(x)[:2] != 'US')]
    # get Analyst series as list
    analysts = df.Analyst.tolist()
    # replace 0 in Analyst list with UNKNOWN with list comprehension
    analysts = ['UNKNOWN' if analyst == 0 else analyst for analyst in analysts]
    # replace Analyst series with list where 0 is now UNKNOWN
    df = df.assign(Analyst=analysts)
    # drop duplicate and shrink dataframe
    df = pd.DataFrame.drop_duplicates(df)
    # format data frame columns
    df = df.astype({'Destination': int, 'Analyst': str})
    # turn on warnings
    warnings.simplefilter('default')
    return df


def prep_upd_data(updr_file: str, mit: str, mskus: list):
    """Prepare requirements view data into dataframe"""
    # turn off warnings
    warnings.simplefilter('ignore')
    # read excel to dataframe
    mit = pd.read_excel(mit, sheet_name='Master Data')
    # reindex columns
    mit = mit[['MSKU Number', 'Alternative Unit of Measure', 'Units per Pallet', 'Net Weight']]
    # format the data frame
    mit = mit.rename(columns={'MSKU Number': 'MSKU', 'Alternative Unit of Measure': 'Base_UoM',
                              'Units per Pallet': 'U_Pallet', 'Net Weight': 'Unit_Wt'})
    # read excel to dataframe
    df = pd.read_excel(updr_file)
    # reindex columns
    df = df[['Availability Date / Requirements Date', 'Category Short Text', 'Receipt Element / Requirements Element',
             'Receipt Quantity / Requirements Quantity', 'Product Number',
             'Base Unit of Measure', 'Target Location', 'Source Location']]
    # format the data frame
    df = df.rename(columns={'Availability Date / Requirements Date': 'Plan_Date', 'Category Short Text': 'Category',
                            'Receipt Element / Requirements Element': 'Order_ID',
                            'Receipt Quantity / Requirements Quantity': 'QTY',
                            'Source Location': 'Origin', 'Target Location': 'Destination',
                            'Product Number': 'MSKU', 'Base Unit of Measure': 'Base_UoM'})
    # filling all missing values in dataframe with 0
    df = df.fillna(0)
    # remove MSKUs listed to avoid if there are any
    if mskus != 0:
        # if MSKU in list of MSKUs -> set as 0
        availmskulist = df['MSKU'].to_list()
        newmskulist = []
        # loop through list of MSKUs in series
        for a in availmskulist:
            # check if MSKU is in list of MSKUs to remove
            if a in mskus:
                # if MSKU in list add a 0 to new list
                newmskulist.append(0)
            else:
                # if MSKU not in list add that MSKU to new list
                newmskulist.append(a)
        # set MSKU series as new list with some MSKUs set as 0
        df['MSKU'] = newmskulist

    # only keep rows where MSKU does not equal 0
    df = df[df.MSKU != 0]
    # convert destination to integer
    df['Destination'] = df['Destination'].astype(int)
    # only keep row if Category == ConRel
    df = df[df['Category'] == 'TLB:VMI-SO']
    # merge MSKU data into requirements view
    df = pd.merge(df, mit, how='inner', on='MSKU')
    # reindex columns
    df = df[['Plan_Date', 'Order_ID', 'QTY', 'MSKU', 'Base_UoM_x',
             'Destination', 'Origin', 'U_Pallet', 'Unit_Wt']]
    # format the data frame
    df = df.rename(columns={'Base_UoM_x': 'Base_UoM'})
    # recalculate QTY to positive
    df['QTY'] = df['QTY'] * -1
    df['Trans_Mode'] = 'Road'
    df['Pallets'] = df['QTY'] / df['U_Pallet']
    # create list of receipt elements (so_id)
    so_id_list = df['Order_ID'].tolist()
    # create blank lists to convert to series
    salesorders = []
    saleslines = []
    # loop through receipt elements to get sales order number and line item
    for so_id in so_id_list:
        try:
            so_nums = so_splitter(so_id)
            salesorders.append(so_nums[0])
            saleslines.append(so_nums[1])
        except ValueError:
            salesorders.append(0)
            saleslines.append(0)
            continue

    # create new series equal to each list
    df['SO'] = salesorders
    df['SO_Line'] = saleslines
    # drop rows where sales order == 0
    df = df[df.SO != 0]
    # create new columns
    df['State'] = plants.get(df['Origin'])
    df['Source_ID'] = df.agg('{0[Origin]}-{0[Destination]}'.format, axis=1)
    df['Order_ID'] = df.agg('{0[SO]}-{0[MSKU]}'.format, axis=1)
    # merge Destination data into requirements view
    df = pd.merge(df, plants, how='left', on='Destination')
    # remove duplicate rows
    df = df.drop_duplicates(subset=['Order_ID'])
    # format the data frame
    df = df.rename(columns={'State_x': 'State'})
    # format 'Plan_Date' column as datetime
    df['Plan_Date'] = pd.to_datetime(df.Plan_Date)
    # calculate week number as new series
    df['Plan_WK'] = df['Plan_Date'].dt.week
    # reindex dataframe
    df = df[['Order_ID', 'Source_ID', 'Plan_WK', 'Origin', 'Trans_Mode', 'Destination', 'State',
             'Base_UoM', 'MSKU', 'SO', 'SO_Line', 'Unit_Wt', 'U_Pallet', 'Pallets']]
    # reset index with Delivery as first column
    df.reset_index(drop=True, inplace=True)
    # create original list of pallets
    pallets = df['Pallets'].tolist()
    o_pallets = df['Pallets'].tolist()
    # create new list of pallets
    newpallets = []
    partialflag = []
    # round down pallet count in dataframe to remove partial pallets
    for pallet in pallets:
        newpallets.append(floor(pallet))
        if pallet.is_integer():
            partialflag.append(0)
        else:
            partialflag.append(1)

    # replace old pallets column with new list
    df['Pallets'] = newpallets
    df['O_Pallets'] = o_pallets
    df['Partial'] = partialflag
    df['Qty'] = df['U_Pallet'] * df['Pallets']
    # create new dataframe for only partial pallets
    pp = df[df['Partial'] == 1]
    # reindex dataframe
    pp = pp[['SO', 'SO_Line', 'MSKU', 'O_Pallets', 'U_Pallet', 'Pallets', 'Qty']]
    # reset index with Delivery as first column
    pp.reset_index(drop=True, inplace=True)
    # reindex dataframe
    df = df[['Order_ID', 'Source_ID', 'Plan_WK', 'Origin', 'Trans_Mode', 'Destination', 'State',
             'Base_UoM', 'MSKU', 'SO', 'SO_Line', 'Unit_Wt', 'U_Pallet', 'Pallets']]
    # remove all rows where pallets == 0
    df = df[df['Pallets'] > 0]
    # sort 1) oldest to newest sales order, 2) kegs then cases, 3) oldest to newest plan week
    df = df.sort_values(by=['SO', 'Base_UoM', 'Plan_WK'], ascending=[True, False, True])
    return df


def import_updr(updr_file: str, mit: str, mskus: list) -> dict:
    """Get source data from requirements view and create sales orders dictionary for distributor orders"""
    # start timer
    begin_time = datetime.datetime.now()
    print(f"  Importing UFD data to dictionary")
    print(f"  Start time:                        {begin_time}")
    # prepare UPD file into dataframe
    df = prep_upd_data(updr_file, mit, mskus)
    # convert data frame to dictionary
    orders = df.set_index('Order_ID').T.to_dict('list')
    # turn warnings back on
    warnings.simplefilter('default')
    # print execution time
    end_time = datetime.datetime.now()
    updr_time = end_time - begin_time
    print(f"  End time:                          {end_time}")
    print(f"  UFD time:                          {updr_time}")
    print(f"  Dictionary created successfully")
    return orders


def import_sto_updr(updr_file: str, mit: str, mskus: list) -> dict:
    """Get source data from requirements view and create sales orders dictionary for stock transport orders"""
    # start timer
    begin_time = datetime.datetime.now()
    print(f"  Importing UFD data to dictionary")
    print(f"  Start time:                        {begin_time}")
    # turn off warnings
    warnings.simplefilter('ignore')
    # read excel to dataframe
    mit = pd.read_excel(mit, sheet_name='Master Data')
    # reindex columns
    mit = mit[['MSKU Number', 'Alternative Unit of Measure', 'Units per Pallet', 'Net Weight']]
    # format the data frame
    mit = mit.rename(columns={'MSKU Number': 'MSKU', 'Alternative Unit of Measure': 'Base_UoM',
                              'Units per Pallet': 'U_Pallet', 'Net Weight': 'Unit_Wt'})
    # read excel to dataframe
    df = pd.read_excel(updr_file)
    # reindex columns
    df = df[['Availability Date / Requirements Date', 'Category Short Text', 'Receipt Element / Requirements Element',
             'Receipt Quantity / Requirements Quantity', 'Product Number',
             'Base Unit of Measure', 'Target Location', 'Source Location']]
    # format the data frame
    df = df.rename(columns={'Availability Date / Requirements Date': 'Plan_Date', 'Category Short Text': 'Category',
                            'Receipt Element / Requirements Element': 'Order_ID',
                            'Receipt Quantity / Requirements Quantity': 'QTY',
                            'Source Location': 'Origin', 'Target Location': 'Destination',
                            'Product Number': 'MSKU', 'Base Unit of Measure': 'Base_UoM'})
    # filling all missing values in dataframe with 0
    df = df.fillna(0)
    # remove MSKUs listed to avoid if there are any
    if mskus != 0:
        # if MSKU in list of MSKUs -> set as 0
        availmskulist = df['MSKU'].to_list()
        newmskulist = []
        # loop through list of MSKUs in series
        for a in availmskulist:
            # check if MSKU is in list of MSKUs to remove
            if a in mskus:
                # if MSKU in list add a 0 to new list
                newmskulist.append(0)
            else:
                # if MSKU not in list add that MSKU to new list
                newmskulist.append(a)
        # set MSKU series as new list with some MSKUs set as 0
        df['MSKU'] = newmskulist

    # only keep rows where MSKU does not equal 0
    df = df[df.MSKU != 0]
    # convert destination to integer
    df['Destination'] = df['Destination'].astype(int)
    # only keep row if Category == ConRel
    df = df[df['Category'] == 'ConRel']
    # merge MSKU data into requirements view
    df = pd.merge(df, mit, how='inner', on='MSKU')
    # reindex columns
    df = df[['Plan_Date', 'Order_ID', 'QTY', 'MSKU', 'Base_UoM_x',
             'Destination', 'Origin', 'U_Pallet', 'Unit_Wt']]
    # format the data frame
    df = df.rename(columns={'Base_UoM_x': 'Base_UoM'})
    # recalculate QTY to positive
    df['QTY'] = df['QTY'] * -1
    df['Trans_Mode'] = 'Road'
    df['Pallets'] = df['QTY'] / df['U_Pallet']
    # create list of receipt elements (so_id)
    so_id_list = df['Order_ID'].tolist()
    # create blank lists to convert to series
    salesorders = []
    saleslines = []
    # loop through receipt elements to get sales order number and line item
    for so_id in so_id_list:
        try:
            so_nums = so_splitter(so_id)
            salesorders.append(so_nums[0])
            saleslines.append(so_nums[1])
        except ValueError:
            salesorders.append(0)
            saleslines.append(0)
            continue

    # create new series equal to each list
    df['SO'] = salesorders
    df['SO_Line'] = saleslines
    # drop rows where sales order == 0
    df = df[df.SO != 0]
    # create new columns
    df['State'] = plants.get(df['Origin'])
    df['Source_ID'] = df.agg('{0[Origin]}-{0[Destination]}'.format, axis=1)
    df['Order_ID'] = df.agg('{0[SO]}-{0[MSKU]}'.format, axis=1)
    # merge Destination data into requirements view
    df = pd.merge(df, plants, how='left', on='Destination')
    # remove duplicate rows
    df = df.drop_duplicates(subset=['Order_ID'])
    # format the data frame
    df = df.rename(columns={'State_x': 'State'})
    # format 'Plan_Date' column as datetime
    df['Plan_Date'] = pd.to_datetime(df.Plan_Date)
    # calculate week number as new series
    df['Plan_WK'] = df['Plan_Date'].dt.week
    # reindex dataframe
    df = df[['Order_ID', 'Source_ID', 'Plan_WK', 'Origin', 'Trans_Mode', 'Destination', 'State',
             'Base_UoM', 'MSKU', 'SO', 'SO_Line', 'Unit_Wt', 'U_Pallet', 'Pallets']]
    # reset index with Delivery as first column
    df.reset_index(drop=True, inplace=True)
    # create original list of pallets
    pallets = df['Pallets'].tolist()
    o_pallets = df['Pallets'].tolist()
    # create new list of pallets
    newpallets = []
    partialflag = []
    # round down pallet count in dataframe to remove partial pallets
    for pallet in pallets:
        newpallets.append(floor(pallet))
        if pallet.is_integer():
            partialflag.append(0)
        else:
            partialflag.append(1)

    # replace old pallets column with new list
    df['Pallets'] = newpallets
    df['O_Pallets'] = o_pallets
    df['Partial'] = partialflag
    df['Qty'] = df['U_Pallet'] * df['Pallets']
    # create new dataframe for only partial pallets
    pp = df[df['Partial'] == 1]
    # reindex dataframe
    pp = pp[['SO', 'SO_Line', 'MSKU', 'O_Pallets', 'U_Pallet', 'Pallets', 'Qty']]
    # reset index with Delivery as first column
    pp.reset_index(drop=True, inplace=True)
    # reindex dataframe
    df = df[['Order_ID', 'Source_ID', 'Plan_WK', 'Origin', 'Trans_Mode', 'Destination', 'State',
             'Base_UoM', 'MSKU', 'SO', 'SO_Line', 'Unit_Wt', 'U_Pallet', 'Pallets']]
    # remove all rows where pallets == 0
    df = df[df['Pallets'] > 0]
    # sort 1) oldest to newest sales order, 2) kegs then cases, 3) oldest to newest plan week
    df = df.sort_values(by=['SO', 'Base_UoM', 'Plan_WK'], ascending=[True, False, True])
    # convert data frame to dictionary
    orders = df.set_index('Order_ID').T.to_dict('list')
    # turn warnings back on
    warnings.simplefilter('default')
    # print execution time
    end_time = datetime.datetime.now()
    updr_time = end_time - begin_time
    print(f"  End time:                          {end_time}")
    print(f"  UFD time:                          {updr_time}")
    print(f"  Dictionary created successfully")
    return orders


def filler_upd_review(wdf, updmitfilename: str, filedate, filesavepath):
    """Compare results from the Wednesday and Friday requirements view reports"""
    # turn off warnings
    warnings.simplefilter('ignore')
    warnings.simplefilter('ignore', category=PendingDeprecationWarning)
    # --------------------------------------------------------------------------------------------------------------
    # create file name as a variable
    updfilename = filesavepath + 'Dash Filler UPD - FM36 - ' + filedate + '.xlsx'
    # rewrite filepath with correct operating system separators
    updfilename = os_split_fixer(updfilename)
    # create a Pandas Excel writer using XlsxWriter as the engine
    writer = pd.ExcelWriter(updfilename, engine='xlsxwriter')
    # --------------------------------------------------------------------------------------------------------------
    # read excel to dataframe
    mit = pd.read_excel(updmitfilename, sheet_name='Customer')
    # reindex columns
    mit = mit[['Customer Number', 'CSA']]
    # format the data frame
    mit = mit.rename(columns={'Customer Number': 'Destination'})
    # filling all missing values in dataframe with 0
    mit = mit.fillna(0)
    # drop rows where sales order == 0
    mit = mit[(mit.CSA != 0) & (mit.Destination != 0)]
    # set destination column as integer data type
    destination = mit['Destination'].to_list()  # convert series to list
    fixed_destination = []  # create new blank list to collect integer correct values
    for d in destination:
        try:
            d = d.strip('0')  # strip leading zeros
            fixed_destination.append(d)  # add corrected value to list
        except ValueError:
            d = 0
            fixed_destination.append(d)
            continue

    # set destination series equal to list stripped of 0s
    mit['Destination'] = fixed_destination
    mit['Destination'] = mit['Destination'].astype(int)  # set series as integer
    # merge MSKU data into requirements view dataframes
    wdf = pd.merge(wdf, mit, how='inner', on='Destination')
    # reindex dataframe
    wdf = wdf[['Order_ID', 'Source_ID', 'Plan_WK', 'Origin', 'Destination', 'CSA', 'Base_UoM',
               'MSKU', 'SO', 'SO_Line', 'Unit_Wt', 'U_Pallet', 'Pallets', 'Units', 'Segment']]
    # --------------------------------------------------------------------------------------------------------------
    wplantnames = []
    wplantregion = []
    worigins = wdf.Origin.to_list()
    for worigin in worigins:
        for source, plant in plantsdict.items():
            name = plant[0]
            region = plant[2]
            if source == worigin:
                wplantnames.append(name)
                wplantregion.append(region)

    wdf['Origin_Name'] = wplantnames
    wdf['Region'] = wplantregion
    # sort dataframe by oos sales to retailers - largest to smallest
    wdf = wdf.sort_values(by=['Units', 'Base_UoM'], ascending=[False, False])
    wdf.reset_index(drop=True, inplace=True)
    wdf.reset_index(inplace=True)
    # wdf['Rank'] = wdf['index'] + 1
    wdf = wdf[['Order_ID', 'Source_ID', 'Plan_WK', 'Region', 'Origin', 'Origin_Name', 'Destination',
               'CSA', 'Base_UoM', 'MSKU', 'SO', 'SO_Line', 'Unit_Wt', 'U_Pallet', 'Pallets', 'Units', 'Segment']]
    # --------------------------------------------------------------------------------------------------------------
    # create list of each region in the dataframe
    wregions = wdf.Region.unique().tolist()
    wreg_pal = []
    wreg_qty = []
    # convert data frame to dictionary
    wregupds = wdf.set_index('Order_ID').T.to_dict('list')
    # get summary results for each csa
    for wreg in wregions:  # iterate through each region in list
        wreg_tot_pallets = 0  # create UPD pallet total variable
        wreg_tot_qty = 0  # create UPD quantity total variable
        for wupdid, wregupd in wregupds.items():  # loop into upd dataframe
            wreg2 = wregupd[2]  # get region name
            wpal = wregupd[13]  # get UPD pal by region
            wqty = wregupd[14]  # get UPD QTY by region
            if wreg == wreg2:  # if regions match
                wreg_tot_pallets = wreg_tot_pallets + wpal  # add pallets to running total
                wreg_tot_qty = wreg_tot_qty + wqty  # add quantity to running total
        wreg_pal.append(wreg_tot_pallets)  # get UPD pallets by region
        wreg_qty.append(wreg_tot_qty)  # get UPD quantity by region

    # create new blank dataframe for csa data
    wregdf = pd.DataFrame()
    wregdf['Region'] = wregions
    wregdf['Pallets'] = wreg_pal
    wregdf['Units'] = wreg_qty
    wregdf = wregdf.sort_values(by=['Units', 'Pallets'], ascending=[False, False])
    wregdf.reset_index(drop=True, inplace=True)
    wregdf.reset_index(inplace=True)
    wregdf['Rank'] = wregdf['index'] + 1
    wregdf = wregdf[['Rank', 'Region', 'Pallets', 'Units']]
    # --------------------------------------------------------------------------------------------------------------
    # get wednesday summary results by CSA
    wcsas = wdf.CSA.unique().tolist()
    wcsa_pal = []
    wcsa_qty = []
    # get summary results for each csa
    for wcsa in wcsas:  # iterate through each CSA in list
        wcsa_tot_pallets = 0  # create UPD pallet total variable
        wcsa_tot_qty = 0  # create UPD quantity total variable
        for wupdid, wregupd in wregupds.items():  # loop into oos dataframe
            wcsa2 = wregupd[6]  # get CSA name
            wcsapal = wregupd[13]  # get pal pal by region
            wcsaqty = wregupd[14]  # get UPD QTY by region
            if wcsa == wcsa2:  # if regions match
                wcsa_tot_pallets = wcsa_tot_pallets + wcsapal  # add pallets to running total
                wcsa_tot_qty = wcsa_tot_qty + wcsaqty  # add quantity to running total
        wcsa_pal.append(wcsa_tot_pallets)  # get UPD pallets by csa
        wcsa_qty.append(wcsa_tot_qty)  # get UPD quantity by csa

    # create new blank dataframe for csa data
    wcsadf = pd.DataFrame()
    wcsadf['CSA'] = wcsas
    wcsadf['Pallets'] = wcsa_pal
    wcsadf['Units'] = wcsa_qty
    wcsadf = wcsadf.sort_values(by=['Units', 'Pallets'], ascending=[False, False])
    wcsadf.reset_index(drop=True, inplace=True)
    wcsadf.reset_index(inplace=True)
    wcsadf['Rank'] = wcsadf['index'] + 1
    wcsadf = wcsadf[['Rank', 'CSA', 'Pallets', 'Units']]
    # --------------------------------------------------------------------------------------------------------------
    # get wednesday summary results by segment
    wsegs = wdf.Segment.unique().tolist()
    wseg_pal = []
    wseg_qty = []
    # get summary results for each segment
    for wseg in wsegs:  # iterate through each segment in list
        wseg_tot_pallets = 0  # create UPD pallet total variable
        wseg_tot_qty = 0  # create UPD quantity total variable
        for wupdid, wregupd in wregupds.items():  # loop into upd dataframe
            wseg2 = wregupd[15]  # get segment name
            wsegpal = wregupd[13]  # get pal pal by segment
            wsegqty = wregupd[14]  # get UPD QTY by segment
            if wseg == wseg2:  # if regions match
                wseg_tot_pallets = wseg_tot_pallets + wsegpal  # add pallets to running total
                wseg_tot_qty = wseg_tot_qty + wsegqty  # add quantity to running total
        wseg_pal.append(wseg_tot_pallets)  # get UPD pallets by segment
        wseg_qty.append(wseg_tot_qty)  # get UPD quantity by segment

    # create new blank dataframe for segment data
    wsegdf = pd.DataFrame()
    wsegdf['Segment'] = wsegs
    wsegdf['Pallets'] = wseg_pal
    wsegdf['Units'] = wseg_qty
    wsegdf = wsegdf.sort_values(by=['Units', 'Pallets'], ascending=[False, False])
    wsegdf.reset_index(drop=True, inplace=True)
    wsegdf.reset_index(inplace=True)
    wsegdf['Rank'] = wsegdf['index'] + 1
    wsegdf = wsegdf[['Rank', 'Segment', 'Pallets', 'Units']]
    # --------------------------------------------------------------------------------------------------------------
    # get wednesday summary results by MSKU
    wskus = wdf.MSKU.unique().tolist()
    wsku_pal = []
    wsku_qty = []
    # get summary results for each segment
    for wsku in wskus:  # iterate through each segment in list
        wsku_tot_pallets = 0  # create UPD pallet total variable
        wsku_tot_qty = 0  # create UPD quantity total variable
        for wupdid, wregupd in wregupds.items():  # loop into upd dataframe
            wsku2 = wregupd[8]  # get MSKU
            wskupal = wregupd[13]  # get pal pal by segment
            wskuqty = wregupd[14]  # get UPD QTY by segment
            if wsku == wsku2:  # if regions match
                wsku_tot_pallets = wsku_tot_pallets + wskupal  # add pallets to running total
                wsku_tot_qty = wsku_tot_qty + wskuqty  # add quantity to running total
        wsku_pal.append(wsku_tot_pallets)  # get UPD pallets by segment
        wsku_qty.append(wsku_tot_qty)  # get UPD quantity by segment

    # create new blank dataframe for segment data
    wskudf = pd.DataFrame()
    wskudf['MSKU'] = wskus
    wskudf['Pallets'] = wsku_pal
    wskudf['Units'] = wsku_qty
    wskudf = wskudf.sort_values(by=['Units', 'Pallets'], ascending=[False, False])
    wskudf.reset_index(drop=True, inplace=True)
    wskudf.reset_index(inplace=True)
    wskudf['Rank'] = wskudf['index'] + 1
    wskudf = wskudf[['Rank', 'MSKU', 'Pallets', 'Units']]
    # --------------------------------------------------------------------------------------------------------------
    # create friday dataframes for central region and get top MSKUs
    wcdf = wdf[wdf.Region == 'CENTRAL']
    wcskus = wcdf.MSKU.unique().tolist()
    wcsku_pal = []
    wcsku_qty = []
    for wcsku in wcskus:  # iterate through each MSKU in list
        wcsku_tot_pallets = 0  # create UPD pallet total variable
        wcsku_tot_qty = 0  # create UPD quantity total variable
        for wupdid, wregupd in wregupds.items():  # loop into upd dataframe
            wcsku2 = wregupd[8]  # get MSKU
            wcskupal = wregupd[13]  # get pal pal by msku
            wcskuqty = wregupd[14]  # get UPD QTY by msku
            if wcsku == wcsku2:  # if mskus match
                wcsku_tot_pallets = wcsku_tot_pallets + wcskupal  # add pallets to running total
                wcsku_tot_qty = wcsku_tot_qty + wcskuqty  # add quantity to running total
        wcsku_pal.append(wcsku_tot_pallets)  # get UPD pallets by msku
        wcsku_qty.append(wcsku_tot_qty)  # get UPD quantity by msku

    wcskudf = pd.DataFrame()
    wcskudf['MSKU'] = wcskus
    wcskudf['Pallets'] = wcsku_pal
    wcskudf['Units'] = wcsku_qty
    wcskudf = wcskudf.sort_values(by=['Units', 'Pallets'], ascending=[False, False])
    wcskudf.reset_index(drop=True, inplace=True)
    wcskudf.reset_index(inplace=True)
    wcskudf['Rank'] = wcskudf['index'] + 1
    wcskudf = wcskudf[['Rank', 'MSKU', 'Pallets', 'Units']]

    # create friday dataframes for great lakes region and get top MSKUs
    wgdf = wdf[wdf.Region == 'GREAT LAKES']
    wgskus = wgdf.MSKU.unique().tolist()
    wgsku_pal = []
    wgsku_qty = []
    for wgsku in wgskus:  # iterate through each MSKU in list
        wgsku_tot_pallets = 0  # create UPD pallet total variable
        wgsku_tot_qty = 0  # create UPD quantity total variable
        for wupdid, wregupd in wregupds.items():  # loop into upd dataframe
            wgsku2 = wregupd[8]  # get MSKU
            wgskupal = wregupd[13]  # get pal pal by msku
            wgskuqty = wregupd[14]  # get UPD QTY by msku
            if wgsku == wgsku2:  # if mskus match
                wgsku_tot_pallets = wgsku_tot_pallets + wgskupal  # add pallets to running total
                wgsku_tot_qty = wgsku_tot_qty + wgskuqty  # add quantity to running total
        wgsku_pal.append(wgsku_tot_pallets)  # get UPD pallets by msku
        wgsku_qty.append(wgsku_tot_qty)  # get UPD quantity by msku

    wgskudf = pd.DataFrame()
    wgskudf['MSKU'] = wgskus
    wgskudf['Pallets'] = wgsku_pal
    wgskudf['Units'] = wgsku_qty
    wgskudf = wgskudf.sort_values(by=['Units', 'Pallets'], ascending=[False, False])
    wgskudf.reset_index(drop=True, inplace=True)
    wgskudf.reset_index(inplace=True)
    wgskudf['Rank'] = wgskudf['index'] + 1
    wgskudf = wgskudf[['Rank', 'MSKU', 'Pallets', 'Units']]

    # create friday dataframes for northeast region and get top MSKUs
    wndf = wdf[wdf.Region == 'NORTHEAST']
    wnskus = wndf.MSKU.unique().tolist()
    wnsku_pal = []
    wnsku_qty = []
    for wnsku in wnskus:  # iterate through each MSKU in list
        wnsku_tot_pallets = 0  # create UPD pallet total variable
        wnsku_tot_qty = 0  # create UPD quantity total variable
        for wupdid, wregupd in wregupds.items():  # loop into upd dataframe
            wnsku2 = wregupd[8]  # get MSKU
            wnskupal = wregupd[13]  # get pal pal by msku
            wnskuqty = wregupd[14]  # get UPD QTY by msku
            if wnsku == wnsku2:  # if mskus match
                wnsku_tot_pallets = wnsku_tot_pallets + wnskupal  # add pallets to running total
                wnsku_tot_qty = wnsku_tot_qty + wnskuqty  # add quantity to running total
        wnsku_pal.append(wnsku_tot_pallets)  # get UPD pallets by msku
        wnsku_qty.append(wnsku_tot_qty)  # get UPD quantity by msku

    wnskudf = pd.DataFrame()
    wnskudf['MSKU'] = wnskus
    wnskudf['Pallets'] = wnsku_pal
    wnskudf['Units'] = wnsku_qty
    wnskudf = wnskudf.sort_values(by=['Units', 'Pallets'], ascending=[False, True])
    wnskudf.reset_index(drop=True, inplace=True)
    wnskudf.reset_index(inplace=True)
    wnskudf['Rank'] = wnskudf['index'] + 1
    wnskudf = wnskudf[['Rank', 'MSKU', 'Pallets', 'Units']]

    # create friday dataframes for pacific region and get top MSKUs
    wpdf = wdf[wdf.Region == 'PACIFIC']
    wpskus = wpdf.MSKU.unique().tolist()
    wpsku_pal = []
    wpsku_qty = []
    for wpsku in wpskus:  # iterate through each MSKU in list
        wpsku_tot_pallets = 0  # create UPD pallet total variable
        wpsku_tot_qty = 0  # create UPD quantity total variable
        for wupdid, wregupd in wregupds.items():  # loop into upd dataframe
            wpsku2 = wregupd[8]  # get MSKU
            wpskupal = wregupd[13]  # get pal pal by msku
            wpskuqty = wregupd[14]  # get UPD QTY by msku
            if wpsku == wpsku2:  # if mskus match
                wpsku_tot_pallets = wpsku_tot_pallets + wpskupal  # add pallets to running total
                wpsku_tot_qty = wpsku_tot_qty + wpskuqty  # add quantity to running total
        wpsku_pal.append(wpsku_tot_pallets)  # get UPD pallets by msku
        wpsku_qty.append(wpsku_tot_qty)  # get UPD quantity by msku

    wpskudf = pd.DataFrame()
    wpskudf['MSKU'] = wpskus
    wpskudf['Pallets'] = wpsku_pal
    wpskudf['Units'] = wpsku_qty
    wpskudf = wpskudf.sort_values(by=['Units', 'Pallets'], ascending=[False, True])
    wpskudf.reset_index(drop=True, inplace=True)
    wpskudf.reset_index(inplace=True)
    wpskudf['Rank'] = wpskudf['index'] + 1
    wpskudf = wpskudf[['Rank', 'MSKU', 'Pallets', 'Units']]

    # create friday dataframes for southeast region and get top MSKUs
    wsdf = wdf[wdf.Region == 'SOUTHEAST']
    wsskus = wsdf.MSKU.unique().tolist()
    wssku_pal = []
    wssku_qty = []
    for wssku in wsskus:  # iterate through each MSKU in list
        wssku_tot_pallets = 0  # create UPD pallet total variable
        wssku_tot_qty = 0  # create UPD quantity total variable
        for wupdid, wregupd in wregupds.items():  # loop into upd dataframe
            wssku2 = wregupd[8]  # get MSKU
            wsskupal = wregupd[13]  # get pal pal by msku
            wsskuqty = wregupd[14]  # get UPD QTY by msku
            if wssku == wssku2:  # if mskus match
                wssku_tot_pallets = wssku_tot_pallets + wsskupal  # add pallets to running total
                wssku_tot_qty = wssku_tot_qty + wsskuqty  # add quantity to running total
        wssku_pal.append(wssku_tot_pallets)  # get UPD pallets by msku
        wssku_qty.append(wssku_tot_qty)  # get UPD quantity by msku

    wsskudf = pd.DataFrame()
    wsskudf['MSKU'] = wsskus
    wsskudf['Pallets'] = wssku_pal
    wsskudf['Units'] = wssku_qty
    wsskudf = wsskudf.sort_values(by=['Units', 'Pallets'], ascending=[False, False])
    wsskudf.reset_index(drop=True, inplace=True)
    wsskudf.reset_index(inplace=True)
    wsskudf['Rank'] = wsskudf['index'] + 1
    wsskudf = wsskudf[['Rank', 'MSKU', 'Pallets', 'Units']]

    # --------------------------------------------------------------------------------------------------------------
    # sort and rank Wednesday req view source dataframe
    wdf = wdf.sort_values(by=['Units', 'Pallets', 'Base_UoM'], ascending=[False, False, True])
    wdf.reset_index(drop=True, inplace=True)
    wdf.reset_index(inplace=True)
    wdf['Rank'] = wdf['index'] + 1
    wdf = wdf[['Rank', 'Order_ID', 'Source_ID', 'Plan_WK', 'Region', 'Origin', 'Origin_Name', 'Destination',
               'CSA', 'Base_UoM', 'MSKU', 'Segment', 'SO', 'SO_Line', 'Unit_Wt', 'U_Pallet', 'Pallets', 'Units']]
    # --------------------------------------------------------------------------------------------------------------
    # write each dataframe to a specific sheet
    wregdf.to_excel(writer, sheet_name='REGION', index=False)
    wcsadf.to_excel(writer, sheet_name='CSA', index=False)
    wsegdf.to_excel(writer, sheet_name='SEGMENT', index=False)
    wskudf.to_excel(writer, sheet_name='MSKU', index=False)
    wdf.to_excel(writer, sheet_name='DETAIL', index=False)
    # fdf.to_excel(writer, sheet_name='FRIDAY', index=False)
    wcskudf.to_excel(writer, sheet_name='CENTRAL', index=False)
    wgskudf.to_excel(writer, sheet_name='GREAT LAKES', index=False)
    wnskudf.to_excel(writer, sheet_name='NORTHEAST', index=False)
    wpskudf.to_excel(writer, sheet_name='PACIFIC', index=False)
    wsskudf.to_excel(writer, sheet_name='SOUTHEAST', index=False)
    # close the Pandas Excel writer and output the Excel file
    writer.save()
    # turn warnings back on
    warnings.simplefilter('default')
    return


def socmir_round(updr_file: str, mit: str):
    """Get source data from requirements view and correctly round the sales order quantity to a full pallet"""
    # start timer
    begin_time = datetime.datetime.now()
    # turn off warnings -> future warnings and chained assignment
    warnings.simplefilter(action='ignore', category=FutureWarning)
    pd.options.mode.chained_assignment = None  # default='warn'
    print(f"  Importing UFD data to dictionary")
    print(f"  Start time:                        {begin_time}")
    # read excel to dataframe
    mit = pd.read_excel(mit, sheet_name='Master Data')
    # reindex columns
    mit = mit[['MSKU Number', 'Alternative Unit of Measure', 'Units per Pallet', 'Net Weight']]  # mat long desc
    # format the data frame
    mit = mit.rename(columns={'MSKU Number': 'MSKU', 'Alternative Unit of Measure': 'Base_UoM',
                              'Units per Pallet': 'U_Pallet', 'Net Weight': 'Unit_Wt'})
    # read excel to dataframe
    df = pd.read_excel(updr_file)
    # reindex columns
    df = df[['Availability Date / Requirements Date', 'Category Short Text', 'Receipt Element / Requirements Element',
             'Receipt Quantity / Requirements Quantity', 'Product Number',
             'Base Unit of Measure', 'Target Location', 'Source Location']]
    # format the data frame
    df = df.rename(columns={'Availability Date / Requirements Date': 'Plan_Date', 'Category Short Text': 'Category',
                            'Receipt Element / Requirements Element': 'Order_ID',
                            'Receipt Quantity / Requirements Quantity': 'QTY',
                            'Source Location': 'Origin', 'Target Location': 'Destination',
                            'Product Number': 'MSKU', 'Base Unit of Measure': 'Base_UoM'})
    # filling all missing values in dataframe with 0
    df = df.fillna(0)
    df['Destination'] = df['Destination'].astype(int)
    # only keep row if Category == ConRel
    df = df[(df['Category'] == 'TLB:VMI-SO') | (df['Category'] == 'ConRel')]
    # merge MSKU data into requirements view
    df = pd.merge(df, mit, how='inner', on='MSKU')
    # reindex columns
    df = df[['Plan_Date', 'Order_ID', 'QTY', 'MSKU', 'Base_UoM_x',
             'Destination', 'Origin', 'U_Pallet', 'Unit_Wt']]
    # format the data frame
    df = df.rename(columns={'Base_UoM_x': 'Base_UoM'})
    # recalculate QTY to positive
    df['QTY'] = df['QTY'] * -1
    df['Trans_Mode'] = 'Road'
    df['Pallets'] = df['QTY'] / df['U_Pallet']
    # create list of receipt elements (so_id)
    so_id_list = df['Order_ID'].tolist()
    # create blank lists to convert to series
    salesorders = []
    saleslines = []
    # loop through receipt elements to get sales order number and line item
    for so_id in so_id_list:
        try:
            so_nums = so_splitter(so_id)
            salesorders.append(so_nums[0])
            saleslines.append(so_nums[1])
        except ValueError:
            salesorders.append(0)
            saleslines.append(0)
            continue

    # create new series equal to each list
    df['SO'] = salesorders
    df['SO_Line'] = saleslines
    # drop rows where sales order == 0
    df = df[df.SO != 0]
    # df['SO_Line'] = df['SO_Line'] - 1
    df['State'] = plants.get(df['Origin'])
    df['Source_ID'] = df.agg('{0[Origin]}-{0[Destination]}'.format, axis=1)
    df['Order_ID'] = df.agg('{0[SO]}-{0[MSKU]}'.format, axis=1)
    # merge Destination data into requirements view
    df = pd.merge(df, plants, how='left', on='Destination')
    # remove duplicate rows
    df = df.drop_duplicates(subset=['Order_ID'])
    # format the data frame
    df = df.rename(columns={'State_x': 'State'})
    # format 'Plan_Date' column as datetime
    df['Plan_Date'] = pd.to_datetime(df.Plan_Date)
    # calculate week number as new series
    df['Plan_WK'] = df['Plan_Date'].dt.week
    # reindex dataframe
    df = df[['Order_ID', 'Source_ID', 'Plan_WK', 'Origin', 'Trans_Mode', 'Destination', 'State',
             'Base_UoM', 'MSKU', 'SO', 'SO_Line', 'Unit_Wt', 'U_Pallet', 'Pallets']]
    # reset index with Delivery as first column
    df.reset_index(drop=True, inplace=True)
    # create original list of pallets
    pallets = df['Pallets'].tolist()
    o_pallets = df['Pallets'].tolist()
    # create new list of pallets
    newpallets = []
    partialflag = []
    # round down pallet count in dataframe to remove partial pallets
    for pallet in pallets:
        newpallets.append(floor(pallet))
        if pallet.is_integer():
            partialflag.append(0)
        else:
            partialflag.append(1)

    # replace old pallets column with new list
    df['Pallets'] = newpallets
    df['O_Pallets'] = o_pallets
    df['O_Qty'] = df['O_Pallets'] * df['U_Pallet']
    df['Partial'] = partialflag
    df['Qty'] = df['U_Pallet'] * df['Pallets']
    # create new dataframe for only partial pallets
    pp = df[df['Partial'] == 1]
    # create extra blank columns for Winshuttle formatting
    pp['Run Log'] = ''
    pp['Validate Log'] = ''
    # reindex dataframe
    pp = pp[['Run Log', 'Validate Log', 'SO', 'SO_Line', 'MSKU', 'O_Pallets', 'O_Qty', 'U_Pallet', 'Pallets', 'Qty']]
    # reset index with Delivery as first column
    pp.reset_index(drop=True, inplace=True)
    # Create winshuttle script excel file
    date = datetime.datetime.today().strftime("%m-%d-%Y")  # mm-dd-yyyy
    # file destination select dialogue
    Tk().withdraw()  # prevent root window
    dirspath = filedialog.askdirectory(title='Select the output file save destination')
    # add correct operating system separator to end of new directory path
    spath = dirspath + os.sep
    # create file name as a variable
    cmirfilename = spath + 'SO Pallet Rounding - FM36 - ' + date + '.xlsx'
    # rewrite filepath with correct operating system separators
    cmirfilename = os_split_fixer(cmirfilename)
    # create a Pandas Excel writer using XlsxWriter as the engine
    writer = pd.ExcelWriter(cmirfilename, engine='xlsxwriter')
    # write each DataFrame to a specific sheet and reset the index
    pp.to_excel(writer, sheet_name='CMIR', index=False)
    # close the Pandas Excel writer and output the Excel file
    writer.save()
    # print execution time
    end_time = datetime.datetime.now()
    updr_time = end_time - begin_time
    print(f"  End time:                          {end_time}")
    print(f"  UFD time:                          {updr_time}")
    print(f"  Sales Order rounding corrected successfully")
    return


def filler_email(wtfilled: int, floadspath: str, todayfiledate, plantsrev: list, mskuexclude: list, totpaladded):
    fillemailstr1 = 'Hello everyone,\n\nPlease find below the results of Dash Filler processing.'
    fillemailstr2 = 'Total Pallets Assigned - ' + str('{:,}'.format(totpaladded))
    fillemailstr3 = 'Total Weight Assigned  - ' + str('{:,}'.format(wtfilled)) + ' lbs'
    fillemailstr4 = ', '.join(str(plant) for plant in plantsrev)
    fillemailstr5 = 'Plants Processed       - ' + fillemailstr4
    fillemailstr8 = '\n\nThe Deliveries file attached lists all orders that were reviewed (for the ' \
                    'above listed plants) and includes details such as weight assigned and ending utilization.'
    fillemailstr9 = '\nThe UPD file attached lists UPD remaining after processing (for the ' \
                    'above listed plants) and includes breakouts by region, CSA, and full sales order details.\n\n'
    # change
    if mskuexclude == 0:
        fillemailstr10 = fillemailstr1 + '\n\n' + fillemailstr2 + '\n' + fillemailstr3 + '\n' + fillemailstr5 + \
                         fillemailstr8 + fillemailstr9
    else:
        fillemailstr6 = ', '.join(str(msku) for msku in mskuexclude)
        fillemailstr7 = 'MSKUs Excluded         - ' + fillemailstr6
        fillemailstr10 = fillemailstr1 + '\n\n' + fillemailstr2 + '\n' + fillemailstr3 + '\n' + fillemailstr5 + '\n' \
                         + fillemailstr7 + fillemailstr8 + fillemailstr9
    # create file name as a variable
    fillemailfilename = floadspath + 'Dash Filler Email - FM36 - ' + todayfiledate + '.txt'
    # create text file object
    fillemail = open(fillemailfilename, 'w+')
    # write email in text file then save and close
    fillemail.write(fillemailstr10)
    fillemail.close()
    return


def load_filler_resfiles(finloads: dict, finorders: dict, mitfile: str, floadspath: str,
                         todayfiledate, mskulist: list, totpaladded: int, updout: int):
    """Create summary files for Deliveries reviewed and UPD remaining post Load Filling"""
    reslo = pd.DataFrame.from_dict(finloads, orient='index', columns=['Source_ID', 'Plan_Date',
                                                                      'Origin', 'Trans_Mode', 'Destination',
                                                                      'State', 'Pallets', 'Gross_Wt', 'To_Fill',
                                                                      'Prefill_%', 'DayInList', 'Wt_Rem'])
    # reset index with Delivery as first column
    reslo.reset_index(inplace=True)
    # rename columns by position
    reslo = reslo.rename(columns={reslo.columns[0]: 'Delivery'})
    # create new columns
    reslo['Target_Wt'] = (reslo['Gross_Wt'] + reslo['To_Fill']).astype(float)
    reslo['Wt_Added'] = (reslo['To_Fill'] - reslo['Wt_Rem']).astype(float)
    reslo['Final_Wt'] = (reslo['Target_Wt'] - reslo['Wt_Rem']).astype(float)
    reslo['Utiliz'] = (1 - (reslo['Wt_Rem'] / reslo['Target_Wt'])).astype(float)
    reslo['Fill_%'] = (reslo['Utiliz'] - reslo['Prefill_%']).astype(float)
    # sort dataframe
    reslo = reslo.sort_values(by='Target_Wt', ascending=True)
    # make index column a series
    reslo.reset_index(inplace=True)
    reslo['Index'] = reslo.index
    # reindex columns
    reslo = reslo[['Index', 'Delivery', 'Source_ID', 'Plan_Date', 'Origin', 'Trans_Mode', 'Destination',
                   'State', 'Pallets', 'Gross_Wt', 'To_Fill', 'Prefill_%', 'DayInList', 'Wt_Rem',
                   'Target_Wt', 'Wt_Added', 'Final_Wt', 'Utiliz', 'Fill_%']]
    # get list of plants reviewed
    plantsrev = reslo.Origin.unique().tolist()
    # rename column
    reslo = reslo.rename(columns={'Index': 'Order'})
    reslo['Order'] = reslo['Order'] + 1
    # duplicate reslo dataframe
    reviewedloads = reslo
    # calc total weight added during dash filler processing
    wtadded = int(round(reslo.Wt_Added.sum()))
    wtneeded = int(round(reslo.Target_Wt.sum() - reslo.Gross_Wt.sum()))
    wtfrac = wtadded / wtneeded
    # take only up to 5000 rows for the dataframe sample
    if len(reslo) > 5000:
        sample = 5000
    else:
        sample = len(reslo)

    # ignore warnings
    warnings.filterwarnings('ignore', module='plotnine')
    # take sample of results from dataframe
    reslo = reslo.sample(n=sample)
    # filter for truck results only
    filled = reslo[(reslo.Final_Wt < 60000) & (reslo.Wt_Added > 0)]
    # format data frame columns
    filled = filled.astype({'Order': int, 'Delivery': str, 'Source_ID': str, 'Origin': str,
                            'Trans_Mode': str, 'Destination': str, 'State': str})
    # calc avg weight added to each order
    avgadd = int(round(filled.Wt_Added.mean(), 0))
    # calc avg weight need for each order
    delfilled = (reslo.Wt_Added > 0).sum() / reslo.Wt_Added.count()
    # calc percent of loads at or above 96% utilization target and change
    utiliz_tar = .96
    utarget = (reslo.Utiliz >= utiliz_tar).sum() / reslo.Utiliz.count()  # at or above .96 final utiliz %
    utargetchg = (reslo['Prefill_%'] >= utiliz_tar).sum() / reslo['Prefill_%'].count()  # at or above .96 beg utiliz %
    utargetchg = utarget - utargetchg
    # calc average change in utilization
    avgperfull = round(reslo.Utiliz.mean(), 2)
    avgperfullchng = round(reslo['Prefill_%'].mean(), 2)
    avgperfullchng = avgperfull - avgperfullchng
    # turn off chained assignments warning
    pd.options.mode.chained_assignment = None  # default='warn'
    # filter for road results only
    reslo = reslo[reslo.Target_Wt < 60000]
    # get most freq target weight
    # target = reslo.Target_Wt.mode()
    # create categorical dataframes
    gross = reslo  # create dataframe for starting weight
    gross = gross[['Order', 'Gross_Wt', 'Origin', 'Prefill_%', 'Plan_Date']]
    gross['Weight'] = gross['Gross_Wt']
    gross['Category'] = 'Starting Weight'
    gross['Utiliz'] = gross['Prefill_%']
    gross['Type'] = 'Starting Utilization'
    gross = gross[['Order', 'Weight', 'Category', 'Origin', 'Utiliz', 'Type', 'Plan_Date']]
    # create dataframe for final weight
    final = reslo
    final = final[['Order', 'Final_Wt', 'Origin', 'Utiliz', 'Plan_Date']]
    final['Weight'] = final['Final_Wt']
    final['Category'] = 'Ending Weight'
    final['Type'] = 'Ending Utilization'
    final = final[['Order', 'Weight', 'Category', 'Origin', 'Utiliz', 'Type', 'Plan_Date']]
    # create dataframe for target weight
    trg = reslo
    trg = trg[['Order', 'Target_Wt', 'Origin', 'Plan_Date']]
    trg['Weight'] = trg['Target_Wt']
    trg['Category'] = 'Target Weight'
    trg['Utiliz'] = 1
    trg['Type'] = 'Target Utilization'
    trg = trg[['Order', 'Weight', 'Category', 'Origin', 'Utiliz', 'Type', 'Plan_Date']]
    # create new concatenated dictionary
    trgdata = pd.concat([gross, final, trg], ignore_index=True)
    typedata = pd.concat([gross, final], ignore_index=True)
    # create categorical dataframe for stacked bar plot
    start = reslo
    start = start[['Order', 'Gross_Wt', 'Origin', 'Plan_Date']]
    start['Weight'] = start['Gross_Wt']
    start['Category'] = 'Starting Weight'
    start = start[['Order', 'Weight', 'Category', 'Origin', 'Plan_Date']]
    # create dataframe for final weight
    added = reslo
    added = added[['Order', 'Wt_Added', 'Origin', 'Plan_Date']]
    added['Weight'] = added['Wt_Added']
    added['Category'] = 'Added Weight'
    added = added[['Order', 'Weight', 'Category', 'Origin', 'Plan_Date']]
    dftarget = reslo
    dftarget = dftarget[['Order', 'Target_Wt', 'Final_Wt', 'Origin', 'Plan_Date']]
    dftarget['Weight'] = dftarget['Target_Wt'] - dftarget['Final_Wt']
    dftarget['Category'] = 'Remaining Weight'
    dftarget = dftarget[['Order', 'Weight', 'Category', 'Origin', 'Plan_Date']]
    # create new concatenated dictionary
    dfbarplot = pd.concat([start, added, dftarget], ignore_index=True)
    dfbarplot = pd.merge(dfbarplot, reslo, how='left', on='Order')
    # format the data frame
    dfbarplot = dfbarplot.rename(columns={'Origin_x': 'Origin', 'Plan_Date_x': 'Plan_Date'})
    dfbarplot = dfbarplot[['Order', 'Weight', 'Category', 'Origin', 'Plan_Date', 'Final_Wt']]
    # get today datetime object
    today = datetime.datetime.today()
    # format as date mm-dd-yyyy
    today = today.strftime("%m-%d-%Y")
    # create plot dashboard
    plotstr1 = target_graph(filled, avgadd, delfilled, floadspath, todayfiledate)
    plotstr2 = targetdist_graph(trgdata, wtadded, wtfrac, floadspath, todayfiledate)
    plotstr3 = boxplot_graph(typedata, utarget, utargetchg, floadspath, todayfiledate)
    plotstr4 = stackedbar_plot(dfbarplot, avgperfull, avgperfullchng, floadspath, todayfiledate)
    # plotstr4 =
    plot1 = Image.open(plotstr1)
    plot2 = Image.open(plotstr2)
    plot3 = Image.open(plotstr3)
    plot4 = Image.open(plotstr4)
    # turn off pending deprecation warnings
    warnings.simplefilter('ignore', category=PendingDeprecationWarning)

    # convert orders dictionary to UPD dataframe
    upd = pd.DataFrame.from_dict(finorders, orient='index', columns=['Source_ID', 'Plan_WK',
                                                                     'Origin', 'Trans_Mode', 'Destination',
                                                                     'State', 'Base_UoM', 'MSKU', 'SO',
                                                                     'SO_Line', 'Unit_Wt', 'U_Pallet', 'Pallets'])
    # drop rows where pallets == 0
    upd = upd[upd.Pallets > 0]
    # reset index with order_id as first column
    upd.reset_index(inplace=True)
    # create new columns
    upd['Units'] = upd['U_Pallet'] * upd['Pallets']
    # format the data frame
    upd = upd.rename(columns={'index': 'Order_ID'})
    mit2 = pd.read_excel(mitfile, sheet_name='Master Data')
    # reindex columns
    mit2 = mit2[['MSKU Number', 'Container Segment']]
    # format the data frame
    mit2 = mit2.rename(columns={'MSKU Number': 'MSKU', 'Container Segment': 'Segment'})
    # merge MSKU data into requirements view
    upd = pd.merge(upd, mit2, how='inner', on='MSKU')
    # reindex the dataframe
    upd = upd[['Order_ID', 'Source_ID', 'Plan_WK', 'Origin', 'Trans_Mode', 'Destination',
               'Base_UoM', 'MSKU', 'SO', 'SO_Line', 'Unit_Wt', 'U_Pallet', 'Pallets', 'Units', 'Segment']]
    # remove duplicate rows
    upd = upd.drop_duplicates(subset=['Order_ID'])
    # check if UPD output is required
    if updout != 1:
        # prepare final UPD summary results file
        filler_upd_review(upd, mitfile, todayfiledate, floadspath)
    # create file name as a variable
    loadsfilename = floadspath + 'Dash Filler Deliveries - FM36 - ' + todayfiledate + '.xlsx'
    # rewrite filepath with correct operating system separators
    loadsfilename = os_split_fixer(loadsfilename)
    # sort Deliveries to review by plan date, then starting utilization, then oldest to newest
    reviewedloads = reviewedloads.sort_values(by=['Plan_Date', 'Prefill_%', 'Delivery'], ascending=[True, True, True])
    # reset index without making a new column
    reviewedloads.reset_index(drop=True, inplace=True)
    # create rank column
    reviewedloads['Rank'] = reviewedloads.index + 1
    # reindex columns
    reviewedloads = reviewedloads[['Rank', 'Delivery', 'Source_ID', 'Plan_Date', 'Origin', 'Trans_Mode',
                                   'Destination', 'State', 'Pallets', 'Gross_Wt', 'To_Fill', 'Prefill_%',
                                   'Wt_Rem', 'Target_Wt', 'Wt_Added', 'Fill_%', 'Final_Wt', 'Utiliz']]
    # create a Pandas Excel writer using XlsxWriter as the engine
    loadsfilewriter = pd.ExcelWriter(loadsfilename, engine='xlsxwriter')
    # create a file and save list of Deliveries that were reviewed
    reviewedloads.to_excel(loadsfilewriter, engine='xlsxwriter', sheet_name='Deliveries', index=False)  # , header=False
    # create workbook and worksheet objects
    loadsworkbook = loadsfilewriter.book
    loadsworksheet = loadsfilewriter.sheets['Deliveries']
    # create formatting methods for workbook
    comma_format = loadsworkbook.add_format({'num_format': '#,##0.00', 'align': 'right'})
    prcnt_format = loadsworkbook.add_format({'num_format': '0.00%', 'align': 'right'})
    center_format = loadsworkbook.add_format({'align': 'center'})
    # Set the column width and format
    loadsworksheet.set_column('A:A', 8.43, center_format)
    loadsworksheet.set_column('B:B', 10, center_format)
    loadsworksheet.set_column('C:C', 11, center_format)
    loadsworksheet.set_column('D:D', 10, center_format)
    loadsworksheet.set_column('E:E', 10, center_format)
    loadsworksheet.set_column('F:F', 11.29, center_format)
    loadsworksheet.set_column('G:G', 10.57, center_format)
    loadsworksheet.set_column('H:H', 6.29, center_format)
    loadsworksheet.set_column('I:I', 10, center_format)
    loadsworksheet.set_column('J:J', 10, comma_format)
    loadsworksheet.set_column('K:K', 10, comma_format)
    loadsworksheet.set_column('L:L', 10, prcnt_format)
    loadsworksheet.set_column('M:M', 10, comma_format)
    loadsworksheet.set_column('N:N', 10, comma_format)
    loadsworksheet.set_column('O:O', 10, comma_format)
    loadsworksheet.set_column('P:P', 10, prcnt_format)
    loadsworksheet.set_column('Q:Q', 10, comma_format)
    loadsworksheet.set_column('R:R', 10, prcnt_format)
    # close the Pandas Excel writer and output the Excel file
    loadsfilewriter.save()
    # create email as text file
    filler_email(wtadded, floadspath, todayfiledate, plantsrev, mskulist, totpaladded)
    # open the final plot result
    plot_finalizer(plot1, plot2, plot3, plot4, floadspath, todayfiledate)
    # turn on pending deprecation warnings
    warnings.simplefilter('default', category=PendingDeprecationWarning)
    return


def upd_resfiles(finorders: dict, mitfile: str, floadspath: str, todayfiledate):
    """Create summary file for UPD remaining post processing"""
    # turn off pending deprecation warnings
    warnings.simplefilter('ignore', category=PendingDeprecationWarning)
    # convert orders dictionary to UPD dataframe
    upd = pd.DataFrame.from_dict(finorders, orient='index', columns=['Source_ID', 'Plan_WK',
                                                                     'Origin', 'Trans_Mode', 'Destination',
                                                                     'State', 'Base_UoM', 'MSKU', 'SO',
                                                                     'SO_Line', 'Unit_Wt', 'U_Pallet', 'Pallets'])
    # drop rows where pallets == 0
    upd = upd[upd.Pallets > 0]
    # reset index with order_id as first column
    upd.reset_index(inplace=True)
    # create new columns
    upd['Units'] = upd['U_Pallet'] * upd['Pallets']
    # format the data frame
    upd = upd.rename(columns={'index': 'Order_ID'})
    mit2 = pd.read_excel(mitfile, sheet_name='Master Data')
    # reindex columns
    mit2 = mit2[['MSKU Number', 'Container Segment']]
    # format the data frame
    mit2 = mit2.rename(columns={'MSKU Number': 'MSKU', 'Container Segment': 'Segment'})
    # merge MSKU data into requirements view
    upd = pd.merge(upd, mit2, how='inner', on='MSKU')
    # reindex the dataframe
    upd = upd[['Order_ID', 'Source_ID', 'Plan_WK', 'Origin', 'Trans_Mode', 'Destination',
               'Base_UoM', 'MSKU', 'SO', 'SO_Line', 'Unit_Wt', 'U_Pallet', 'Pallets', 'Units', 'Segment']]
    # remove duplicate rows
    upd = upd.drop_duplicates(subset=['Order_ID'])
    # prepare final UPD summary results file
    filler_upd_review(upd, mitfile, todayfiledate, floadspath)
    # turn on pending deprecation warnings
    warnings.simplefilter('default', category=PendingDeprecationWarning)
    return


def light_load_filling(loads: dict, orders: dict, gatps: dict, projis: dict, mskulist: list, dirname: str, mitfile: str,
                       s_s_time, step1_time, step2_time, step3_time, n_orders: dict, all_orders: dict, updout: int):
    """Use input dictionaries, files, and times to fill light loads"""
    # Delete key values pairs in orders dictionary that have no matches in the loads dictionary
    print(f"\n//////////////////////////////////////////////////////////////////////")
    print(f"  Removing unusable Unplanned Demand")
    # loop into orders dictionary to find source_id matches between loads and orders dictionaries
    for demand, order in orders.items():
        matches = 0  # create new variable to count matches
        usource_id = order[0]  # grab source_id for matching
        mode = order[3]  # grab trans_mode
        # count number of matches each order has in the loads dictionary
        for delivery, load in loads.items():
            lsource_id = load[0]  # grab source_id for matching
            if lsource_id == usource_id:
                matches = matches + 1  # add 1 to the match running total
            else:
                continue

        # set pallets to 0 if order source ID has no matches in loads dictionary or if trans_mode == 0
        if matches == 0 or mode == 0:
            # set available pallets to 0
            order[12] = 0
        else:
            continue

    print(f"  Unmatched Unplanned Demand identified")
    # list of keys to be deleted from dictionary
    selectedkeys = []
    # iterate over the list and add keys where pallets == 0 to a list
    for demand, order in orders.items():
        u_pallets = order[12]  # grab number of pallets
        # delete dictionary key if 0 pallets are available on the order
        if u_pallets == 0:
            # if 0 pallets are available
            selectedkeys.append(demand)
        else:
            # if there are pallets available -> skip
            continue

    # iterate over the list and delete corresponding key from dictionary
    for key in selectedkeys:
        # if key is found in list
        if key in orders:
            # delete key from order orders dictionary
            del orders[key]

    print(f"  Unmatched Unplanned Demand deleted successfully")
    # Calculate starting totals for final results
    all_pallets = 0
    # loop into orders dictionary
    for demand, order in orders.items():
        # get number of pallets available for each key
        u_pallets = order[12]
        # add pallets available to a running total
        all_pallets = all_pallets + u_pallets

    # loop into loads dictionary to find source_id matches between loads and orders dictionaries
    for delivery, load in loads.items():
        lsource_id = load[0]  # grab source_id for matching
        lmatches = 0  # create new variable to count matches
        lmode = load[3]  # grab trans_mode
        for demand, order in orders.items():
            usource_id = order[0]  # grab source_id for matching
            # count number of matches each order has in the loads dictionary
            if lsource_id == usource_id:
                lmatches = lmatches + 1  # add 1 to the match running total
            else:
                continue

        # set pallets to 0 if order source ID has no matches in loads dictionary or if trans_mode == 0
        if lmatches == 0 or lmode == 0:
            # set to_fill to 0
            load[8] = 0
        else:
            continue

    print(f"  Unmatched Deliveries identified")
    # list of keys to be deleted from dictionary
    selectedloads = []
    # iterate over the list and add keys where pallets == 0 to a list
    for delivery, load in loads.items():
        to_fill = load[8]  # grab to_fill value
        # delete dictionary key if 0 pallets are available on the order
        if to_fill == 0:  # if to_fill is 0
            selectedloads.append(delivery)
        else:
            # if to_fill not 0 -> skip
            continue

    # iterate over the list and delete corresponding key from dictionary
    for key in selectedloads:
        # if key is found in list
        if key in loads:
            # delete key from order orders dictionary
            del loads[key]

    print(f"  Unmatched Deliveries deleted successfully")
    print(f"  Calculating total ToFill value for all Deliveries reviewed")
    # calculate total tofill value for all active loads
    total_tofill = 0
    for delivery, load in loads.items():
        total_tofill = total_tofill + load[8]  # grab source_id for matching

    print(f"  Calculating total weight of Unplanned Demand")
    # calculate total tofill value for all active loads
    total_updwt = 0
    for demand, order in orders.items():
        updwt = (order[10] * order[11] * order[12])  # unit_wt * units per pallet * pallets
        total_updwt = total_updwt + updwt  # update total weight of unplanned demand

    print(f"  Finding state values for unplanned demand")
    # find state for each distributor and update order dictionary
    for delivery, load in loads.items():
        lsource_id = load[0]  # get id for matching
        state = load[5]  # get state for filling
        for demand, order in orders.items():
            usource_id = order[0]  # get id for matching
            if lsource_id == usource_id:  # if ids match
                order[5] = state  # update state in orders dict

    print(f"\n//////////////////////////////////////////////////////////////////////")
    print(f"  Total Deliveries Reviewed:         {'{:,}'.format(len(loads.keys()))}")
    print(f"  Total Weight ToFill:               {'{:,.2f}'.format(total_tofill)}")
    print(f"  UPD Pallets Available:             {'{:,}'.format(all_pallets)}")
    print(f"  UPD Weight Available:              {'{:,.2f}'.format(total_updwt)}")
    if mskulist != 0:
        print(f"  MSKUs Excluded:                    {mskulist}")
    # Create winshuttle script excel file
    date = datetime.datetime.today().strftime("%m-%d-%Y")  # mm-dd-yyyy
    # file destination select dialogue
    Tk().withdraw()  # prevent root window
    dirspath = filedialog.askdirectory(title='Select the output file save destination')
    dirsavepath = os_split_fixer(dirspath + os.sep + dirname)
    os.mkdir(dirsavepath)
    spath = dirsavepath + os.sep
    # create file name as a variable
    filename = spath + 'Dash Filler - FM36 - ' + date + '.xlsx'
    # rewrite filepath with correct operating system separators
    filename = os_split_fixer(filename)
    # Create a workbook and add a worksheet.
    workbook = xlsxwriter.Workbook(filename)
    worksheet = workbook.add_worksheet('Script')
    # create formatting methods
    comma_format = workbook.add_format({'num_format': '#,##0.00', 'align': 'right'})
    prcnt_format = workbook.add_format({'num_format': '0.00%', 'align': 'right'})
    merge_format = workbook.add_format({'align': 'center', 'italic': True, 'bold': True})
    right_format = workbook.add_format({'align': 'right'})
    center_format = workbook.add_format({'align': 'center'})
    bold_format = workbook.add_format({'bold': True, 'align': 'center'})
    # write workbook headers for script output
    worksheet.write(0, 0, 'RUN LOG', bold_format)  # cell A1
    worksheet.write(0, 1, 'VALIDATE LOG', bold_format)  # cell B1
    worksheet.write(0, 2, 'Delivery', bold_format)  # cell C1
    worksheet.write(0, 3, 'Select Date', bold_format)  # cell D1
    worksheet.write(0, 4, 'Sales Order', bold_format)  # cell E1
    worksheet.write(0, 5, 'Line Item', bold_format)  # cell F1
    worksheet.write(0, 6, 'Line Item', bold_format)  # cell G1
    worksheet.write(0, 7, 'MSKU', bold_format)  # cell H1
    worksheet.write(0, 8, 'Units', bold_format)  # cell I1
    worksheet.write(0, 9, 'Plan Date', bold_format)  # cell J1
    worksheet.write(0, 10, 'Order ID', bold_format)  # cell K1
    worksheet.write(0, 11, 'Gross Wt', bold_format)  # cell L1
    worksheet.write(0, 12, 'Start ToFill', bold_format)  # cell M1
    worksheet.write(0, 13, 'Wt Assigned', bold_format)  # cell N1
    worksheet.write(0, 14, 'Plts Assigned', bold_format)  # cell O1
    worksheet.write(0, 15, 'New ToFill', bold_format)  # cell P1
    worksheet.write(0, 16, 'Wt Rem', bold_format)  # cell Q1
    worksheet.write(0, 17, 'Fill %', bold_format)  # cell R1
    # write phase 1 execution results
    worksheet.merge_range('S1:T1', 'Dash Filler Results', merge_format)
    # write summary results
    worksheet.write(1, 18, 'Total Pllts Assigned')  # cell S2
    worksheet.write(1, 19, '=SUM($O:$O)', comma_format)  # cell T2
    worksheet.write(2, 18, 'Total Wt Assigned')  # cell S3
    worksheet.write(2, 19, '=SUM($N:$N)', comma_format)  # cell T3
    worksheet.write(3, 18, 'Full Truck Equivalent')  # cell S4
    worksheet.write(3, 19, '=$T$3/43500', comma_format)  # cell T4
    worksheet.write(4, 18, 'Avg Start ToFill')  # cell S5
    worksheet.write(4, 19, '=AVERAGE($M:$M)', comma_format)  # cell T5
    worksheet.write(5, 18, 'Avg Wt Remaining')  # cell S6
    worksheet.write(5, 19, '=AVERAGE($Q:$Q)', comma_format)  # cell T6
    worksheet.write(6, 18, 'Avg Wt Filled')  # cell S7
    worksheet.write(6, 19, '=$T$5-$T$6', comma_format)  # cell T7
    worksheet.write(7, 18, 'Avg Fill %')  # cell S8
    worksheet.write(7, 19, '=AVERAGE($R:$R)', prcnt_format)  # cell T8
    worksheet.write(8, 18, 'Execution Time')  # cell S9
    worksheet.write(9, 18, 'Total Wt ToFill')  # cell S10
    worksheet.write(9, 19, total_tofill, comma_format)  # cell T10
    worksheet.write(10, 18, 'Total ToFill % Filled')  # cell S11
    worksheet.write(10, 19, '=$T$3/$T$10', prcnt_format)  # cell T11
    # set column widths by range
    worksheet.set_column(0, 0, 65)  # A:A
    worksheet.set_column(1, 1, 13)  # B:B
    worksheet.set_column(2, 9, 11)  # C:J
    worksheet.set_column(10, 10, 18)  # K:K
    worksheet.set_column(11, 13, 11)  # L:N
    worksheet.set_column(14, 14, 12)  # O:O
    worksheet.set_column(15, 17, 11)  # P:R
    worksheet.set_column(18, 18, 20.29)  # S:S
    worksheet.set_column(19, 19, 13.14)  # T:T
    # Start the main assignment loop
    row = 1  # set starting row
    print(f"\n//////////////////////////////////////////////////////////////////////")
    print(f"  Beginning unplanned demand assignment")
    # start timer
    a_begin_time = datetime.datetime.now()
    print(f"  Start time:                        {a_begin_time}")
    # create pallet counting variable
    tot_pal_added = 0
    # loop through dictionary of loads to work on
    for delivery, load in loads.items():
        # grab values from dictionary list
        lsource_id = load[0]  # Source ID
        gross_wt = load[7]  # Gross Wt
        to_fill = load[8]  # To Fill
        plan_date = load[1]  # Plan Date
        dayindex = load[10]  # position in date range window
        # calculate selection date - Today + 1 year
        today_date = datetime.datetime.today()  # return today's date
        n_year_today = today_date + datetime.timedelta(days=365)  # calculate next year today
        s_date = n_year_today.strftime('%m/%d/%Y')  # format as mm/dd/yyyy
        # for each load, loop through dictionary of UPD available to find assignment matches
        for demand, order in orders.items():
            usource_id = order[0]  # order source_id
            order_week = order[1]  # sales order week
            origin = order[2]  # origin plant
            msku = order[7]  # msku
            uatp_id = str(str(origin) + '-' + str(msku))  # plant + msku
            so = order[8]  # sales order
            line = order[9]  # sales order line item
            unit_wt = order[10]  # unit weight
            u_p_pal = order[11]  # units per pallet
            pallets = order[12]  # pallets
            pallet_wt = unit_wt * u_p_pal  # pallet weight
            # make assignment if source_ids match
            if lsource_id == usource_id:
                # loop into gatp dictionary
                for pair, gatp in gatps.items():
                    # trim list to only days inventory can be assigned to the Delivery
                    avail_inv = list(gatp[:dayindex])
                    # get max available inventory from subindexed gatp list
                    atp = max(avail_inv, default=0)
                    # make assignment if gatp_ids match and there is product available
                    if uatp_id == pair and atp > 0:
                        # get projected inventory limit from dictionary
                        for projipair, proji in projis.items():
                            # find gATP match in both available QTY and projected inventory dictionaries
                            if projipair == uatp_id:
                                # get proj inv limit and proj inv week to adjust (if any)
                                weekcheck_limitlist = weekcheck_limiter(list(proji), plan_date, order_week)
                                projiwklimit = weekcheck_limitlist[0]  # proj inv limit
                                projiwk_to_adj = weekcheck_limitlist[1]  # proj inv week to adjust
                                # calculate how much UPD to assign using the assign() function
                                assigned = assign(target=to_fill, p_wt=pallet_wt, t_plt=pallets,
                                                  u_plt=u_p_pal, atp=atp, pi_limit=projiwklimit)
                                # [t_plt, filled, n_target, atp] output list from assign() function
                                tot_plt = assigned[0]  # total pallets assigned
                                a_filled = assigned[1]  # weight assigned
                                n_to_fill = assigned[2]  # new to fill target
                                units = tot_plt * u_p_pal  # calc units were assigned
                                # if units were assigned
                                if units > 0:
                                    # update orders dictionary with new pallets available
                                    order[12] = pallets - tot_plt  # new pallets available
                                    # add number of pallets added to running total variable
                                    tot_pal_added = tot_pal_added + tot_plt
                                    # store to fill before assignment
                                    orig_to_fill = to_fill  # to fill before assignment
                                    # update to fill amount with new target to fill amount
                                    to_fill = n_to_fill  # lower to fill by more amount assigned
                                    # update gatps dictionary with new inventory available
                                    futurefixer(gatp, units)
                                    # adjust projected inventory if needed
                                    if projiwk_to_adj == 'week 1':
                                        # update proji dictionary for week 1
                                        proji[0] = proji[0] - units
                                    elif projiwk_to_adj == 'week 2':
                                        # update proji dictionary for week 2
                                        proji[1] = proji[1] - units
                                    elif projiwk_to_adj == 'both':
                                        # update proji dictionary for both week 1 and week 2
                                        proji[0] = proji[0] - units
                                        proji[1] = proji[1] - units
                                    # print results in next row of script file
                                    worksheet.write(row, 2, delivery)  # column C - Delivery
                                    worksheet.write(row, 3, s_date, center_format)  # column D - Select Date
                                    worksheet.write(row, 4, so)  # column E - Sales Order
                                    worksheet.write(row, 5, line)  # column F - Line Item
                                    worksheet.write(row, 6, line)  # column G - Line Item
                                    worksheet.write(row, 7, msku)  # column H - MSKU
                                    worksheet.write(row, 8, units, right_format)  # column I - Units
                                    worksheet.write(row, 9, plan_date, center_format)  # column J - Plan Date
                                    worksheet.write(row, 10, usource_id, center_format)  # column K - Order ID
                                    worksheet.write(row, 11, gross_wt, comma_format)  # column L - Gross Wt
                                    worksheet.write(row, 12, orig_to_fill, comma_format)  # column M - Start ToFill
                                    worksheet.write(row, 13, a_filled, comma_format)  # column N - Wt Assigned
                                    worksheet.write(row, 14, tot_plt, right_format)  # column O - Plts Assigned
                                    worksheet.write(row, 15, to_fill, comma_format)  # column P - New ToFill
                                    # increase row index
                                    row += 1
                                else:
                                    # if no units are assigned continue to next line
                                    continue
                            else:
                                # if atp_ids do not match continue to next line
                                continue
                    else:
                        # if gatp ids do not match continue to next line
                        continue
            else:
                # if source ids do not match continue to next line
                continue
        # add weight remaining to load list
        load.append(to_fill)
    # Main Loop Wrap Up
    row += 1  # increase row index final time
    # distinguish variables to prevent continuity issues
    row1 = row
    row2 = row
    print(f"  Dash Filling completed")
    print(f"  Entering formulas")
    # input formula for column Q starting in cell Q2
    for i in range(2, row1):
        # =IF($C3<>$C2,$P2,"-")
        cell1 = '$C' + str(i + 1)
        cell2 = '$C' + str(i)
        cell3 = '$P' + str(i)
        formula = '=IF(' + cell1 + '<>' + cell2 + ',' + cell3 + ',"-")'
        irow = i - 1
        # input string as formula
        worksheet.write(irow, 16, formula, comma_format)

    # input formula for column R starting in cell R2
    for i in range(2, row2):
        # =IF($C3<>$C2,(($L2+$M2)-$P2)/($L2+$M2),"-")
        cell1 = '$C' + str(i + 1)
        cell2 = '$C' + str(i)
        cell3 = '$L' + str(i)
        cell4 = '$P' + str(i)
        cell5 = '$M' + str(i)
        formula = ('=IF(' + cell1 + '<>' + cell2 + ',((' + cell3 + '+' + cell5 + ')-'
                   + cell4 + ')/(' + cell3 + '+' + cell5 + ')' + ',"-")')
        irow = i - 1  # input row
        # input string as formula
        worksheet.write(irow, 17, formula, prcnt_format)

    # Calculate totals for final results in load_filler
    print(f"  Totaling unplanned demand assigned")
    # create new variable to sum remaining pallets
    count_pallets = 0
    # loop into orders dictionary
    for demand, order in orders.items():
        # get remaining pallets available
        u_pallets = order[12]
        # add pallets available to running total variable
        count_pallets = count_pallets + u_pallets

    print(f"  Assignment completed")
    # print execution time
    a_end_time = datetime.datetime.now()
    assign_time = a_end_time - a_begin_time
    e_assign_time = str(assign_time)
    print(f"  Assign time:                        {assign_time}")
    # add in results fields to cell T9
    worksheet.write(8, 19, e_assign_time)
    # close created workbook
    workbook.close()
    print(f"  End time:                           {a_end_time}")
    # calc results
    print(f"\n//////////////////////////////////////////////////////////////////////")
    # start timer
    r_begin_time = datetime.datetime.now()
    print(f"  Calculating results")
    print(f"  Start time:                         {r_begin_time}")
    # create output delivery and UPD summary results files and save to new directory
    load_filler_resfiles(loads, orders, mitfile, spath, date, mskulist, tot_pal_added, updout)
    # end timer
    r_end_time = datetime.datetime.now()
    # calc duration
    results_time = r_end_time - r_begin_time
    print(f"  End time:                           {r_end_time}")
    print(f"  Results time:                       {results_time}")
    # print total script execution and results time
    s_e_time = datetime.datetime.now()
    t_script_time = s_e_time - s_s_time
    print(f"\n//////////////////////////////////////////////////////////////////////")
    print(f"  Your Winshuttle script has been created successfully!")
    print(f"  Total Dash Filler Unplanned Demand assignment time")
    print(f"  Import Loads data:                  {step1_time}")
    print(f"  Import Orders data:                 {step2_time}")
    print(f"  Import gATP data:                   {step3_time}")
    print(f"  Assignment time:                    {assign_time}")
    print(f"  Results time:                       {results_time}")
    print(f"  Dash Filler execution time:                         {t_script_time}")
    print(f"\n//////////////////////////////////////////////////////////////////////")
    return [orders, gatps, projis, n_orders, all_orders, t_script_time, spath]


def load_filler(lwvrfile: str, updrfile: str, gatpfile: str, mitfile: str,
                dunnage: int, dirname: str, mskulist: list, updout: int):
    """Main function that assigns product to deliveries based on availability"""
    # Send startup messages and begin timers
    print(f"\n//////////////////////////////////////////////////////////////////////")
    s_s_time = datetime.datetime.now()
    print(f"  Dash Filler unplanned demand assignment")
    print(f"  {apptitle}")
    print(f"  Starting script timer")
    print(f"  Start time:                        {s_s_time}")
    print(f"  Defining script functions")
    print(f"  Functions and methods defined successfully")
    print(f"\n//////////////////////////////////////////////////////////////////////")
    # start timer 1
    btime1 = datetime.datetime.now()
    # import loads dictionary
    loads = import_lwvr(lwvrfile, dunnage)
    etime1 = datetime.datetime.now()
    step1_time = etime1 - btime1
    print(f"  Load Weight Filler Report dictionary imported successfully")
    print(f"\n//////////////////////////////////////////////////////////////////////")
    # start timer 2
    btime2 = datetime.datetime.now()
    # import orders dictionary
    orders = import_updr(updrfile, mitfile, mskulist)
    etime2 = datetime.datetime.now()
    step2_time = etime2 - btime2
    print(f"  Requirements View Report dictionary imported successfully")
    # deep copy orders to create a separate dictionary for assignment
    n_orders = deepcopy(orders)
    # deep copy orders to create a separate dictionary as loads to create
    all_orders = deepcopy(orders)
    print(f"\n//////////////////////////////////////////////////////////////////////")
    # start timer 3
    btime3 = datetime.datetime.now()
    # import orders dictionary
    gatpresults = import_gatp(gatpfile, mitfile)
    # get available qty dictionary as first result from import_gATP
    gatps = gatpresults[0]
    # get projected inventory dictionary as second result from import_gATP
    projis = gatpresults[1]
    # calculate gatp end time
    etime3 = datetime.datetime.now()
    # calculate total gatp import time
    step3_time = etime3 - btime3
    print(f"  Global Available to Promise dictionary imported successfully")
    [orders, gatps,  projis, n_orders, all_orders, t_script_time, spath] = light_load_filling(loads, orders, gatps,
                                                                                              projis, mskulist, dirname,
                                                                                              mitfile, s_s_time,
                                                                                              step1_time, step2_time,
                                                                                              step3_time, n_orders,
                                                                                              all_orders, updout)
    return [orders, gatps,  projis, n_orders, all_orders, t_script_time, spath]


def ewm_load_filler(lwvrfile: str, updrfile: str, gatpfile: str, mitfile: str,
                    dunnage: int, dirname: str, mskulist: list, updout: int):
    """Main function that assigns product to deliveries based on availability"""
    # Send startup messages and begin timers
    print(f"\n//////////////////////////////////////////////////////////////////////")
    s_s_time = datetime.datetime.now()
    print(f"  Dash Filler unplanned demand assignment")
    print(f"  Starting script timer")
    print(f"  Start time:                        {s_s_time}")
    print(f"  Defining script functions")
    print(f"  Functions and methods defined successfully")
    print(f"\n//////////////////////////////////////////////////////////////////////")
    # start timer 1
    btime1 = datetime.datetime.now()
    # import loads dictionary
    loads = ewm_import_lwvr(lwvrfile, dunnage)
    etime1 = datetime.datetime.now()
    step1_time = etime1 - btime1
    print(f"  Load Weight Filler Report dictionary imported successfully")
    print(f"\n//////////////////////////////////////////////////////////////////////")
    # start timer 2
    btime2 = datetime.datetime.now()
    # import orders dictionary
    orders = import_updr(updrfile, mitfile, mskulist)
    etime2 = datetime.datetime.now()
    step2_time = etime2 - btime2
    print(f"  Requirements View Report dictionary imported successfully")
    # deep copy orders to create a separate dictionary for assignment
    n_orders = deepcopy(orders)
    # deep copy orders to create a separate dictionary as loads to create
    all_orders = deepcopy(orders)
    print(f"\n//////////////////////////////////////////////////////////////////////")
    # start timer 3
    btime3 = datetime.datetime.now()
    # import orders dictionary
    gatpresults = ewm_import_gatp(gatpfile, mitfile)
    # get available qty dictionary as first result from import_gATP
    gatps = gatpresults[0]
    # get projected inventory dictionary as second result from import_gATP
    projis = gatpresults[1]
    # calculate gatp end time
    etime3 = datetime.datetime.now()
    # calculate total gatp import time
    step3_time = etime3 - btime3
    print(f"  Global Available to Promise dictionary imported successfully")
    [orders, gatps, projis, n_orders, all_orders, t_script_time, spath] = light_load_filling(loads, orders, gatps,
                                                                                             projis, mskulist, dirname,
                                                                                             mitfile, s_s_time,
                                                                                             step1_time, step2_time,
                                                                                             step3_time, n_orders,
                                                                                             all_orders, updout)
    return [orders, gatps, projis, n_orders, all_orders, t_script_time, spath]


def sto_load_filler(lwvrfile: str, updrfile: str, gatpfile: str, mitfile: str,
                    dunnage: int, dirname: str, mskulist: list, updout: int):
    """Main function that assigns product to deliveries based on availability"""
    # Send startup messages and begin timers
    print(f"\n//////////////////////////////////////////////////////////////////////")
    s_s_time = datetime.datetime.now()
    print(f"  Dash Filler unplanned demand assignment")
    print(f"  {apptitle}")
    print(f"  Starting script timer")
    print(f"  Start time:                        {s_s_time}")
    print(f"  Defining script functions")
    print(f"  Functions and methods defined successfully")
    print(f"\n//////////////////////////////////////////////////////////////////////")
    # start timer 1
    btime1 = datetime.datetime.now()
    # import loads dictionary
    loads = import_lwvr(lwvrfile, dunnage)
    etime1 = datetime.datetime.now()
    step1_time = etime1 - btime1
    print(f"  Load Weight Filler Report dictionary imported successfully")
    print(f"\n//////////////////////////////////////////////////////////////////////")
    # start timer 2
    btime2 = datetime.datetime.now()
    # import orders dictionary
    orders = import_sto_updr(updrfile, mitfile, mskulist)
    etime2 = datetime.datetime.now()
    step2_time = etime2 - btime2
    print(f"  Requirements View Report dictionary imported successfully")
    # deep copy orders to create a separate dictionary for assignment
    n_orders = deepcopy(orders)
    # deep copy orders to create a separate dictionary as loads to create
    all_orders = deepcopy(orders)
    print(f"\n//////////////////////////////////////////////////////////////////////")
    # start timer 3
    btime3 = datetime.datetime.now()
    # import orders dictionary
    gatpresults = import_gatp(gatpfile, mitfile)
    # get available qty dictionary as first result from import_gATP
    gatps = gatpresults[0]
    # get projected inventory dictionary as second result from import_gATP
    projis = gatpresults[1]
    # calculate gatp end time
    etime3 = datetime.datetime.now()
    # calculate total gatp import time
    step3_time = etime3 - btime3
    print(f"  Global Available to Promise dictionary imported successfully")
    [orders, gatps,  projis, n_orders, all_orders, t_script_time, spath] = light_load_filling(loads, orders, gatps,
                                                                                              projis, mskulist, dirname,
                                                                                              mitfile, s_s_time,
                                                                                              step1_time, step2_time,
                                                                                              step3_time, n_orders,
                                                                                              all_orders, updout)
    return [orders, gatps,  projis, n_orders, all_orders, t_script_time, spath]


def delivery_planner(lwvrfile: str, updrfile, gatpfile, mitfile: str, dunnage: int, dirname: str,
                     mskulist: list, cutoff: float, plan_date: str, leftovers, projis, rerun: int, spath: str):
    """Plan new deliveries with UPD """
    # Send startup messages and begin timers
    print(f"\n//////////////////////////////////////////////////////////////////////")
    s_s_time = datetime.datetime.now()
    print(f"  Dash Filler New Order Planner")
    print(f"  {apptitle}")
    print(f"  Starting script timer")
    print(f"  Start time:                        {s_s_time}")
    print(f"  Defining script functions")
    print(f"  Functions and methods defined successfully")
    print(f"\n//////////////////////////////////////////////////////////////////////")
    # # start timer 1
    btime1 = datetime.datetime.now()
    # get lane weights be source_id
    prelanes = prep_lane_wt(lwvrfile, dunnage)
    # get analyst by plant and customer
    analystdf = lane_analyst(lwvrfile)
    # create series of minimum successful delivery weight
    prelanes['Target'] = prelanes['Lane_Wt'] * float(cutoff)
    # convert data frame to dictionary
    loads = prelanes.set_index('Source_ID').T.to_dict('list')
    etime1 = datetime.datetime.now()
    step1_time = etime1 - btime1
    print(f"  Load Weight Filler Report dictionary imported successfully")
    print(f"\n//////////////////////////////////////////////////////////////////////")
    # start timer 2
    btime2 = datetime.datetime.now()
    # check if this is load_both
    if rerun == 1:
        # import orders dictionary from input file
        orders = import_updr(updrfile, mitfile, mskulist)
        # update values in orders dictionary with what was used to fill existing loads
        orders.update(leftovers)
    else:
        # import orders dictionary from input file
        orders = import_updr(updrfile, mitfile, mskulist)
    # create list of all UPD ids
    new_order_ids = []
    # get source id as first element in list for each key in orders dict and add to list
    for key, order in orders.items():
        new_order_ids.append(order[0])
    etime2 = datetime.datetime.now()
    step2_time = etime2 - btime2
    print(f"  Requirements View Report dictionary imported successfully")
    print(f"\n//////////////////////////////////////////////////////////////////////")
    # start timer 3
    btime3 = datetime.datetime.now()
    # check if gATP is input as dictionary or str
    if type(gatpfile) is dict:
        # load_both function will pass the updated dictionary from the load_filler function
        gatps = gatpfile
    else:
        # import gATP dictionary
        gatpresults = import_gatp(gatpfile, mitfile)
        # get available qty dictionary as first result from import_gATP
        gatps = gatpresults[0]
        # get projected inventory dictionary as second result from import_gATP
        projis = gatpresults[1]
    # calculate gatp end time
    etime3 = datetime.datetime.now()
    # calculate total gatp import time
    step3_time = etime3 - btime3
    print(f"  Global Available to Promise dictionary imported successfully")
    # Delete key values pairs in orders dictionary that have no matches in the loads dictionary
    print(f"\n//////////////////////////////////////////////////////////////////////")
    print(f"  Removing unusable Unplanned Demand")
    # loop into orders dictionary to find source_id matches between loads and orders dictionaries
    for demand, order in orders.items():
        matches = 0  # create new variable to count matches
        usource_id = order[0]  # grab source_id for matching
        mode = order[3]  # grab trans_mode
        # count number of matches each order has in the loads dictionary
        for lane, load in loads.items():
            if lane == usource_id:
                matches = matches + 1  # add 1 to the match running total
            else:
                continue

        # set pallets to 0 if order source ID has no matches in loads dictionary or if trans_mode == 0
        if matches == 0 or mode == 0:
            # set available pallets to 0
            order[12] = 0
        else:
            continue

    print(f"  Unmatched Unplanned Demand identified")
    # list of keys to be deleted from dictionary
    selectedkeys = []
    # iterate over the list and add keys where pallets == 0 to a list
    for demand, order in orders.items():
        u_pallets = order[12]  # grab number of pallets
        # delete dictionary key if 0 pallets are available on the order
        if u_pallets == 0:
            # if 0 pallets are available
            selectedkeys.append(demand)
        else:
            # if there are pallets available -> skip
            continue

    # iterate over the list and delete corresponding key from dictionary
    for key in selectedkeys:
        # if key is found in list
        if key in orders:
            # delete key from order orders dictionary
            del orders[key]

    print(f"  Unmatched Unplanned Demand deleted successfully")
    # loop into loads dictionary to find source_id matches between loads and orders dictionaries
    for lane, load in loads.items():
        lmatches = 0  # create new variable to count matches
        for demand, order in orders.items():
            usource_id = order[0]  # grab source_id for matching
            # count number of matches each order has in the loads dictionary
            if lane == usource_id:
                lmatches = lmatches + 1  # add 1 to the match running total
            else:
                continue
        # set pallets to 0 if order source ID has no matches in loads dictionary or if trans_mode == 0
        if lmatches == 0:
            # set cutoff to 0
            load[1] = 0
        else:
            continue
    print(f"  Unmatched Deliveries identified")
    # list of keys to be deleted from dictionary
    selectedloads = []
    # iterate over the list and add keys where pallets == 0 to a list
    for lane, load in loads.items():
        cutoffwt = load[0]  # grab to_fill value
        # delete dictionary key if 0 pallets are available on the order
        if cutoffwt == 0:  # if to_fill is 0
            selectedloads.append(lane)
        else:   # if to_fill not 0 -> skip
            continue
    # iterate over the list and delete corresponding key from dictionary
    for key in selectedloads:
        if key in loads:    # if key is found in list
            del loads[key]  # delete key from order orders dictionary

    print(f"  Unmatched lanes deleted successfully")
    # Calculate starting totals for final results
    all_pallets = 0
    # loop into orders dictionary
    for demand, order in orders.items():
        # get number of pallets available for each key
        u_pallets = order[12]
        # add pallets available to a running total
        all_pallets = all_pallets + u_pallets

    print(f"  Calculating total weight of Unplanned Demand")
    # calculate total tofill value for all active loads
    total_updwt = 0
    for demand, order in orders.items():
        updwt = (order[10] * order[11] * order[12])  # unit_wt * units per pallet * pallets
        total_updwt = total_updwt + updwt  # update total weight of unplanned demand

    print(f"\n//////////////////////////////////////////////////////////////////////")
    print(f"  UPD Pallets Available:             {'{:,}'.format(all_pallets)}")
    print(f"  UPD Weight Available:              {'{:,.2f}'.format(total_updwt)}")
    if mskulist != 0:
        print(f"  MSKUs Excluded:                    {mskulist}")
    # Create winshuttle script excel file
    date = datetime.datetime.today().strftime("%m-%d-%Y")  # mm-dd-yyyy
    # check if this is load_both
    if rerun != 1:
        # file destination select dialogue
        Tk().withdraw()  # prevent root window
        dirspath = filedialog.askdirectory(title='Select the output file save destination')
        dirsavepath = os_split_fixer(dirspath + os.sep + dirname)
        os.mkdir(dirsavepath)
        spath = dirsavepath + os.sep
    # create file name as a variable
    filename = spath + 'Dash Planner - FM36 - ' + date + '.xlsx'
    # rewrite filepath with correct operating system separators
    filename = os_split_fixer(filename)
    # create a Pandas Excel writer using XlsxWriter as the engine
    loadsfilewriter = pd.ExcelWriter(filename, engine='xlsxwriter')
    # create workbook and worksheet objects
    loadsworkbook = loadsfilewriter.book
    worksheet = loadsworkbook.add_worksheet('Script')
    # create worksheet objects to save each dataframe to
    analystdf.to_excel(loadsfilewriter, engine='xlsxwriter', sheet_name='Analyst', index=False)
    worksheet2 = loadsfilewriter.sheets['Analyst']
    # create formatting methods
    comma_format = loadsworkbook.add_format({'num_format': '#,##0.00', 'align': 'right'})
    prcnt_format = loadsworkbook.add_format({'num_format': '0.00%', 'align': 'right'})
    merge_format = loadsworkbook.add_format({'align': 'center', 'italic': True, 'bold': True})
    right_format = loadsworkbook.add_format({'align': 'right'})
    left_format = loadsworkbook.add_format({'align': 'left'})
    center_format = loadsworkbook.add_format({'align': 'center'})
    bold_format = loadsworkbook.add_format({'bold': True, 'align': 'center'})
    # formats for conditional formatting
    bad_format = loadsworkbook.add_format({'bg_color': '#FFC7CE', 'font_color': '#9C0006'})
    good_format = loadsworkbook.add_format({'bg_color': '#C6EFCE', 'font_color': '#006100'})
    # write workbook headers for script output
    worksheet.write(0, 0, 'RUN LOG', bold_format)  # cell A1
    worksheet.write(0, 1, 'Analyst', bold_format)  # cell B1
    worksheet.write(0, 2, 'Delivery', bold_format)  # cell C1
    worksheet.write(1, 2, 1)  # cell C2
    worksheet.write(0, 3, 'Select Date', bold_format)  # cell D1
    worksheet.write(0, 4, 'Sales Order', bold_format)  # cell E1
    worksheet.write(0, 5, 'Line Item 1', bold_format)  # cell F1
    worksheet.write(0, 6, 'Line Item 2', bold_format)  # cell G1
    worksheet.write(0, 7, 'MSKU', bold_format)  # cell H1
    worksheet.write(0, 8, 'Units', bold_format)  # cell I1
    worksheet.write(0, 9, 'Plan Date', bold_format)  # cell J1
    worksheet.write(0, 10, 'Order ID', bold_format)  # cell K1
    worksheet.write(0, 11, 'Gross Wt', bold_format)  # cell L1
    worksheet.write(0, 12, 'Start ToFill', bold_format)  # cell M1
    worksheet.write(0, 13, 'Wt Assigned', bold_format)  # cell N1
    worksheet.write(0, 14, 'Plts Assigned', bold_format)  # cell O1
    worksheet.write(0, 15, 'New ToFill', bold_format)  # cell P1
    worksheet.write(0, 16, 'Target Met', bold_format)  # cell Q1
    worksheet.merge_range('R1:S1', 'Dash Planner Filled Results', merge_format)
    worksheet.write(0, 19, 'Order', bold_format)  # cell T1
    worksheet.write(0, 20, 'Status', bold_format)  # cell U1
    worksheet.write(0, 21, 'Lines', bold_format)  # cell V1
    worksheet.write(0, 22, 'Wt Rem', bold_format)  # cell W1
    worksheet.write(0, 23, 'Fill %', bold_format)  # cell X1
    worksheet.write(0, 24, 'Plts Assigned', bold_format)  # cell Y1
    # write summary results
    worksheet.write(1, 17, 'Total Pllts Assigned')  # cell S2
    worksheet.write(1, 18, '=SUMIFS($O:$O,$Q:$Q,1)', comma_format)  # cell T2
    worksheet.write(2, 17, 'Total Wt Assigned')  # cell S3
    worksheet.write(2, 18, '=SUMIFS($N:$N,$Q:$Q,1)', comma_format)  # cell T3
    worksheet.write(3, 17, 'Filled Orders Created')  # cell S4
    worksheet.write(3, 18, '=COUNTIFS($U:$U,"Filled")')  # cell T4
    worksheet.write(4, 17, 'Avg Start ToFill')  # cell S5
    worksheet.write(4, 18, '=AVERAGE($L:$L)', comma_format)  # cell T5
    worksheet.write(5, 17, 'Avg Wt Remaining')  # cell S6
    worksheet.write(5, 18, '=AVERAGEIFS($W:$W,$U:$U,"Filled")', comma_format)  # cell T6
    worksheet.write(6, 17, 'Avg Wt Filled')  # cell S7
    worksheet.write(6, 18, '=$S$5-$S$6', comma_format)  # cell T7
    worksheet.write(7, 17, 'Avg Filled Order %')  # cell S8
    worksheet.write(7, 18, '=IFERROR(AVERAGEIFS($X:$X,$U:$U,"Filled"),"-")', prcnt_format)  # cell T8
    worksheet.write(8, 17, 'Execution Time')  # cell S9
    worksheet.write(9, 17, 'Total UPD Wt Available')  # cell S10
    worksheet.write(9, 18, total_updwt, comma_format)  # cell T10
    worksheet.write(10, 17, 'Total UPD % Assigned')  # cell S11
    worksheet.write(10, 18, '=$S$3/$S$10', prcnt_format)  # cell T11
    # set column widths by range for worksheet
    worksheet.set_column(0, 0, 40)  # A:A
    worksheet.set_column(1, 1, 23)  # B:B
    worksheet.set_column(2, 13, 11)  # C:N
    worksheet.set_column(14, 14, 12)  # O:O
    worksheet.set_column(15, 16, 11)  # P:R
    worksheet.set_column(17, 17, 21)  # R:R
    worksheet.set_column(18, 18, 13.5)  # S:S
    worksheet.set_column(19, 23, 10)  # T:X
    worksheet.set_column(24, 24, 12)  # Y:Y
    # set column widths by range for worksheet2
    worksheet2.set_column(0, 0, 12)  # A:A
    worksheet2.set_column(1, 1, 23)  # B:B
    # Start the main assignment loop
    row = 1  # set starting row
    print(f"\n//////////////////////////////////////////////////////////////////////")
    print(f"  Beginning unplanned demand assignment")
    # start timer
    a_begin_time = datetime.datetime.now()
    print(f"  Start time:                        {a_begin_time}")
    # create pallet counting variable
    tot_pal_added = 0
    # calculate day range window
    day_window = dynamicdayrange()
    dayrange = day_window[0]
    # loop through list of new orders to make
    for new_order_id in new_order_ids:
        # loop through dictionary of loads to work on
        for lane, load in loads.items():
            # grab values from dictionary list
            lsource_id = lane  # Source ID
            gross_wt = 0  # Gross Wt
            to_fill = load[0]  # Target full truck weight
            # convert plan date to timestamp
            plan_date = pd.to_datetime(plan_date)
            # format as mm/dd/yyyy
            plan_date = plan_date.strftime('%m/%d/%Y')
            # calc plan date position in list
            dayindex = dayrange.index(plan_date) + 1
            # calculate selection date - Today + 1 year
            today_date = datetime.datetime.today()  # return today's date
            n_year_today = today_date + datetime.timedelta(days=365)  # calculate next year today
            s_date = n_year_today.strftime('%m/%d/%Y')  # format as mm/dd/yyyy
            if lsource_id == new_order_id:
                # for each load, loop through dictionary of UPD available to find assignment matches
                for demand, order in orders.items():
                    usource_id = order[0]  # order source_id
                    order_week = order[1]  # sales order week
                    origin = order[2]  # origin plant
                    msku = order[7]  # msku
                    uatp_id = str(str(origin) + '-' + str(msku))  # plant + msku
                    so = order[8]  # sales order
                    line = order[9]  # sales order line item
                    unit_wt = order[10]  # unit weight
                    u_p_pal = order[11]  # units per pallet
                    pallets = order[12]  # pallets
                    pallet_wt = unit_wt * u_p_pal  # pallet weight
                    # make assignment if source_ids match
                    if lsource_id == usource_id:
                        # loop into gatp dictionary
                        for pair, gatp in gatps.items():
                            # trim list to only days inventory can be assigned to the Delivery
                            avail_inv = list(gatp[:dayindex])
                            # get max available inventory from subindexed gatp list
                            atp = max(avail_inv, default=0)
                            # make assignment if gatp_ids match and there is product available
                            if uatp_id == pair and atp > 0:
                                # get projected inventory limit from dictionary
                                for projipair, proji in projis.items():
                                    # find gATP match in both available QTY and projected inventory dictionaries
                                    if projipair == uatp_id:
                                        # get proj inv limit and proj inv week to adjust (if any)
                                        weekcheck_limitlist = weekcheck_limiter(list(proji), plan_date, order_week)
                                        projiwklimit = weekcheck_limitlist[0]  # proj inv limit
                                        projiwk_to_adj = weekcheck_limitlist[1]  # proj inv week to adjust
                                        # calculate how much UPD to assign using the assign() function
                                        assigned = assign(target=to_fill, p_wt=pallet_wt, t_plt=pallets,
                                                          u_plt=u_p_pal, atp=atp, pi_limit=projiwklimit)
                                        # [t_plt, filled, n_target, atp] output list from assign() function
                                        tot_plt = assigned[0]  # total pallets assigned
                                        a_filled = assigned[1]  # weight assigned
                                        n_to_fill = assigned[2]  # new to fill target
                                        units = tot_plt * u_p_pal  # calc units were assigned
                                        # if units were assigned
                                        if units > 0:
                                            # update orders dictionary with new pallets available
                                            order[12] = pallets - tot_plt  # new pallets available
                                            # add number of pallets added to running total variable
                                            tot_pal_added = tot_pal_added + tot_plt
                                            # store to fill before assignment
                                            orig_to_fill = to_fill  # to fill before assignment
                                            # update to fill amount with new target to fill amount
                                            to_fill = n_to_fill  # lower to fill by more amount assigned
                                            # update gatps dictionary with new inventory available
                                            futurefixer(gatp, units)
                                            # adjust projected inventory if needed
                                            if projiwk_to_adj == 'week 1':
                                                # update proji dictionary for week 1
                                                proji[0] = proji[0] - units
                                            elif projiwk_to_adj == 'week 2':
                                                # update proji dictionary for week 2
                                                proji[1] = proji[1] - units
                                            elif projiwk_to_adj == 'both':
                                                # update proji dictionary for both week 1 and week 2
                                                proji[0] = proji[0] - units
                                                proji[1] = proji[1] - units
                                            # print results in next row of script file
                                            # worksheet.write(row, 2, delivery)  # column C - Delivery
                                            worksheet.write(row, 3, s_date, center_format)  # column D - Select Date
                                            worksheet.write(row, 4, so)  # column E - Sales Order
                                            worksheet.write(row, 5, line)  # column F - Line Item
                                            worksheet.write(row, 6, line)  # column G - Line Item
                                            worksheet.write(row, 7, msku)  # column H - MSKU
                                            worksheet.write(row, 8, units, right_format)  # column I - Units
                                            worksheet.write(row, 9, plan_date, center_format)  # column J - Plan Date
                                            worksheet.write(row, 10, usource_id, center_format)  # column K - Order ID
                                            worksheet.write(row, 11, gross_wt, comma_format)  # column L - Gross Wt
                                            worksheet.write(row, 12, orig_to_fill, comma_format)  # column M - Start ToFill
                                            worksheet.write(row, 13, a_filled, comma_format)  # column N - Wt Assigned
                                            worksheet.write(row, 14, tot_plt, right_format)  # column O - Plts Assigned
                                            worksheet.write(row, 15, to_fill, comma_format)  # column P - New ToFill
                                            # increase row index
                                            row += 1
                                        else:
                                            # if no units are assigned continue to next line
                                            continue
                                    else:
                                        # if atp_ids do not match continue to next line
                                        continue
                            else:
                                # if gatp ids do not match continue to next line
                                continue
                    else:
                        # if source ids do not match continue to next line
                        continue
                # add weight remaining to load list
                load.append(to_fill)
                # add new element to load list to track is load created is under cutoff
                if to_fill <= cutoff:
                    load.append(1)  # add TRUE boolean to indicate success
                else:
                    load.append(0)  # add FALSE boolean to indicate failure
    # Main Loop Wrap Up
    row += 1  # increase row index final time
    # distinguish variables to prevent continuity issues
    row1 = row
    row2 = row
    row5 = row - 1
    row6 = row
    row7 = row
    row8 = row
    row9 = row
    print(f"  Dash Planning completed")
    print(f"  Entering formulas")
    # input formula for column c starting in cell B2
    for i in range(2, row1):
        # =IFERROR(VLOOKUP(VALUE(RIGHT($K2,FIND("-",$K2)+1)),Analyst!$A:$B,2,FALSE),"-")
        inp_cell = 'B' + str(i)
        cell1 = '$K' + str(i)
        formula = '=IFERROR(VLOOKUP(VALUE(RIGHT(' + cell1 + ',FIND("-",' + cell1 + ')+1)),Analyst!$A:$B,2,FALSE),"-")'
        # input string as formula
        worksheet.write_formula(inp_cell, formula, left_format)

    # input formula for column c starting in cell C3
    for i in range(3, row1):
        # =IF(AND(P2>P3,K3=K2),C2,C2+1)
        inp_cell = 'C' + str(i)
        cell1 = 'P' + str(i - 1)
        cell2 = 'P' + str(i)
        cell3 = 'K' + str(i)
        cell4 = 'K' + str(i - 1)
        cell5 = 'C' + str(i - 1)
        formula = '=IF(AND(' + cell1 + '>' + cell2 + ',' + cell3 + '=' + cell4 + '),' + cell5 + ',' + cell5 + '+1)'
        # input string as formula
        worksheet.write_formula(inp_cell, formula)

    # input formula for column c starting in cell L2
    for i in range(2, row1):
        # =IFERROR(VLOOKUP($C3,$C:$M,11,FALSE),"-")
        inp_cell = 'L' + str(i)
        cell1 = '$C' + str(i)
        formula = '=IFERROR(VLOOKUP(' + cell1 + ',$C:$M,11,FALSE),"-")'
        # input string as formula
        worksheet.write_formula(inp_cell, formula, comma_format)

    # input formula for column n starting in cell Q2
    for i in range(2, row2):
        # =IF(LOOKUP($C2,$C:$P)<=(1-{cutoff})*$L2,1,0)
        inp_cell = 'Q' + str(i)
        cell1 = '$C' + str(i)
        cell2 = '$L' + str(i)
        formula = '=IF(LOOKUP(' + cell1 + ',$C:$P)<=(1-' + str(cutoff) + ')*' + cell2 + ',1,0)'
        # input string as formula
        worksheet.write_formula(inp_cell, formula)

    # input load completion count list starting in cell T2
    l_comp = 1
    for i in range(1, row5):
        # inp_cell = 'T' + str(i)
        # worksheet.write_formula(inp_cell, l_comp1)
        worksheet.write(i, 19, l_comp, left_format)
        l_comp += 1

    # input formula for column r starting in cell U2
    for i in range(2, row6):
        # =IF(T2>{last cell in C},"-",IF(VLOOKUP($T2,$C:$Q,15,FALSE)=1,"Filled", "Light"))
        inp_cell = 'U' + str(i)
        cell1 = '$T' + str(i)
        cell2 = '$C$' + str(row1 - 1)
        formula = '=IF(' + cell1 + '>' + cell2 + ',"-",IF(VLOOKUP(' + cell1 + ',$C:$Q,15,FALSE)=1,"Filled", "Light"))'
        # input string as formula
        worksheet.write_formula(inp_cell, formula)

    # input formula for column s starting in cell V2
    for i in range(2, row7):
        # =IF($U2="-","-",COUNTIF($C:$C,$T2))
        inp_cell = 'V' + str(i)
        cell1 = 'U' + str(i)
        cell2 = 'T' + str(i)
        formula = '=IF($' + cell1 + '="-","-",COUNTIF($C:$C,$' + cell2 + '))'
        # input string as formula
        worksheet.write_formula(inp_cell, formula, right_format)

    # input formula for column s starting in cell W2
    for i in range(2, row8):
        # =IFERROR(INDEX($C:$P,MATCH($T2,$C:$C,0)+$V2-1,14),"-")
        inp_cell = 'W' + str(i)
        cell1 = 'T' + str(i)
        cell2 = 'V' + str(i)
        formula = '=IFERROR(INDEX($C:$P,MATCH($' + cell1 + ',$C:$C,0)+$' + cell2 + '-1,14),"-")'
        # input string as formula
        worksheet.write_formula(inp_cell, formula, comma_format)

    # input formula for column s starting in cell X2
    for i in range(2, row8):
        # =IFERROR(1-($W2/VLOOKUP($T2,$C:$M,11,FALSE)),"-")
        inp_cell = 'X' + str(i)
        cell1 = '$W' + str(i)
        cell2 = '$T' + str(i)
        formula = '=IFERROR(1-(' + cell1 + '/VLOOKUP(' + cell2 + ',$C:$M,11,FALSE)),"-")'
        # input string as formula
        worksheet.write_formula(inp_cell, formula, prcnt_format)

    # input formula for column s starting in cell Y2
    for i in range(2, row9):
        # =IF(COUNTIFS($O:$O,$T2)=0,"-",COUNTIFS($O:$O,$T2))
        inp_cell = 'Y' + str(i)
        cell1 = 'T' + str(i)
        formula = '=IF(COUNTIFS($O:$O,$' + cell1 + ')=0,"-",COUNTIFS($O:$O,$' + cell1 + '))'
        # input string as formula
        worksheet.write_formula(inp_cell, formula, right_format)

    warnings.simplefilter('ignore')  # turn off warnings
    # set conditional formatting on planned order results
    cfrng = 'U2:U' + str(row9 - 1)
    worksheet.conditional_format(cfrng, {'type': 'cell', 'criteria': '==', 'value': '"Light"', 'format': bad_format})
    worksheet.conditional_format(cfrng, {'type': 'cell', 'criteria': '==', 'value': '"Filled"', 'format': good_format})
    # conditional format with data bars for formula range in column X
    x_range = 'X2:X' + str(row9 - 1)
    worksheet.conditional_format(x_range, {'type': 'data_bar', 'bar_border_color': '091F3F', 'bar_color': 'D8E0E4'})
    warnings.simplefilter('default')    # turn warnings back on
    # Calculate totals for final results in load_filler
    print(f"  Totaling unplanned demand assigned")
    # create new variable to sum remaining pallets
    count_pallets = 0
    # loop into orders dictionary
    for demand, order in orders.items():
        # get remaining pallets available
        u_pallets = order[12]
        # add pallets available to running total variable
        count_pallets = count_pallets + u_pallets

    print(f"  Assignment completed")
    # print execution time
    a_end_time = datetime.datetime.now()
    assign_time = a_end_time - a_begin_time
    e_assign_time = str(assign_time)
    print(f"  Assign time:                        {assign_time}")
    # add in results fields to cell T9
    worksheet.write(8, 18, e_assign_time)
    # close created workbook
    loadsfilewriter.close()
    print(f"  End time:                           {a_end_time}")
    # calc results
    print(f"\n//////////////////////////////////////////////////////////////////////")
    # start timer
    r_begin_time = datetime.datetime.now()
    print(f"  Calculating results")
    print(f"  Start time:                         {r_begin_time}")
    # calculate results and create UPD remaining output
    upd_resfiles(orders, mitfile, spath, date)
    # end timer
    r_end_time = datetime.datetime.now()
    # calc duration
    results_time = r_end_time - r_begin_time
    print(f"  End time:                           {r_end_time}")
    print(f"  Results time:                       {results_time}")
    # print total script execution and results time
    s_e_time = datetime.datetime.now()
    t_script_time = s_e_time - s_s_time
    print(f"\n//////////////////////////////////////////////////////////////////////")
    print(f"  Your Winshuttle script has been created successfully!")
    print(f"  Total Dash Filler Unplanned Demand assignment time")
    print(f"  Import Loads data:                  {step1_time}")
    print(f"  Import Orders data:                 {step2_time}")
    print(f"  Import gATP data:                   {step3_time}")
    print(f"  Assignment time:                    {assign_time}")
    print(f"  Results time:                       {results_time}")
    print(f"  Dash Filler execution time:                         {t_script_time}")
    print(f"\n//////////////////////////////////////////////////////////////////////")
    return


def sto_planner(lwvrfile: str, updrfile, gatpfile, mitfile: str, dunnage: int, dirname: str,
                mskulist: list, cutoff: float, plan_date: str, leftovers: dict, projis, rerun: int, spath: str):
    """Plan new stock transport orders with UPD"""
    # Send startup messages and begin timers
    print(f"\n//////////////////////////////////////////////////////////////////////")
    s_s_time = datetime.datetime.now()
    print(f"  Dash Filler New Order Planner")
    print(f"  {apptitle}")
    print(f"  Starting script timer")
    print(f"  Start time:                        {s_s_time}")
    print(f"  Defining script functions")
    print(f"  Functions and methods defined successfully")
    print(f"\n//////////////////////////////////////////////////////////////////////")
    # # start timer 1
    btime1 = datetime.datetime.now()
    # get lane weights be source_id
    prelanes = prep_lane_wt(lwvrfile, dunnage)
    # get analyst by plant and customer
    analystdf = lane_analyst(lwvrfile)
    # create series of minimum successful delivery weight
    prelanes['Target'] = prelanes['Lane_Wt'] * float(cutoff)
    # convert data frame to dictionary
    loads = prelanes.set_index('Source_ID').T.to_dict('list')
    etime1 = datetime.datetime.now()
    step1_time = etime1 - btime1
    print(f"  Load Weight Filler Report dictionary imported successfully")
    print(f"\n//////////////////////////////////////////////////////////////////////")
    # start timer 2
    btime2 = datetime.datetime.now()
    # check if this is load_both
    if rerun == 1:
        # import orders dictionary from input file
        orders = import_sto_updr(updrfile, mitfile, mskulist)
        # update values in orders dictionary with what was used to fill existing loads
        orders.update(leftovers)
    else:
        # import orders dictionary from input file
        orders = import_sto_updr(updrfile, mitfile, mskulist)
    # create list of all UPD ids
    new_order_ids = []
    # get source id as first element in list for each key in orders dict and add to list
    for key, order in orders.items():
        new_order_ids.append(order[0])
    etime2 = datetime.datetime.now()
    step2_time = etime2 - btime2
    print(f"  Requirements View Report dictionary imported successfully")
    print(f"\n//////////////////////////////////////////////////////////////////////")
    # start timer 3
    btime3 = datetime.datetime.now()
    # check if gATP is input as dictionary or str
    if type(gatpfile) is dict:
        # load_both function will pass the updated dictionary from the load_filler function
        gatps = gatpfile
    else:
        # import gATP dictionary
        gatpresults = import_gatp(gatpfile, mitfile)
        # get available qty dictionary as first result from import_gATP
        gatps = gatpresults[0]
        # get projected inventory dictionary as second result from import_gATP
        projis = gatpresults[1]
    # calculate gatp end time
    etime3 = datetime.datetime.now()
    # calculate total gatp import time
    step3_time = etime3 - btime3
    print(f"  Global Available to Promise dictionary imported successfully")
    # Delete key values pairs in orders dictionary that have no matches in the loads dictionary
    print(f"\n//////////////////////////////////////////////////////////////////////")
    print(f"  Removing unusable Unplanned Demand")
    # loop into orders dictionary to find source_id matches between loads and orders dictionaries
    for demand, order in orders.items():
        matches = 0  # create new variable to count matches
        usource_id = order[0]  # grab source_id for matching
        mode = order[3]  # grab trans_mode
        # count number of matches each order has in the loads dictionary
        for lane, load in loads.items():
            if lane == usource_id:
                matches = matches + 1  # add 1 to the match running total
            else:
                continue

        # set pallets to 0 if order source ID has no matches in loads dictionary or if trans_mode == 0
        if matches == 0 or mode == 0:
            # set available pallets to 0
            order[12] = 0
        else:
            continue

    print(f"  Unmatched Unplanned Demand identified")
    # list of keys to be deleted from dictionary
    selectedkeys = []
    # iterate over the list and add keys where pallets == 0 to a list
    for demand, order in orders.items():
        u_pallets = order[12]  # grab number of pallets
        # delete dictionary key if 0 pallets are available on the order
        if u_pallets == 0:
            # if 0 pallets are available
            selectedkeys.append(demand)
        else:
            # if there are pallets available -> skip
            continue

    # iterate over the list and delete corresponding key from dictionary
    for key in selectedkeys:
        # if key is found in list
        if key in orders:
            # delete key from order orders dictionary
            del orders[key]

    print(f"  Unmatched Unplanned Demand deleted successfully")
    # loop into loads dictionary to find source_id matches between loads and orders dictionaries
    for lane, load in loads.items():
        lmatches = 0  # create new variable to count matches
        for demand, order in orders.items():
            usource_id = order[0]  # grab source_id for matching
            # count number of matches each order has in the loads dictionary
            if lane == usource_id:
                lmatches = lmatches + 1  # add 1 to the match running total
            else:
                continue
        # set pallets to 0 if order source ID has no matches in loads dictionary or if trans_mode == 0
        if lmatches == 0:
            # set cutoff to 0
            load[1] = 0
        else:
            continue
    print(f"  Unmatched Deliveries identified")
    # list of keys to be deleted from dictionary
    selectedloads = []
    # iterate over the list and add keys where pallets == 0 to a list
    for lane, load in loads.items():
        cutoffwt = load[0]  # grab to_fill value
        # delete dictionary key if 0 pallets are available on the order
        if cutoffwt == 0:  # if to_fill is 0
            selectedloads.append(lane)
        else:  # if to_fill not 0 -> skip
            continue
    # iterate over the list and delete corresponding key from dictionary
    for key in selectedloads:
        if key in loads:  # if key is found in list
            del loads[key]  # delete key from order orders dictionary

    print(f"  Unmatched lanes deleted successfully")
    # Calculate starting totals for final results
    all_pallets = 0
    # loop into orders dictionary
    for demand, order in orders.items():
        # get number of pallets available for each key
        u_pallets = order[12]
        # add pallets available to a running total
        all_pallets = all_pallets + u_pallets

    print(f"  Calculating total weight of Unplanned Demand")
    # calculate total tofill value for all active loads
    total_updwt = 0
    for demand, order in orders.items():
        updwt = (order[10] * order[11] * order[12])  # unit_wt * units per pallet * pallets
        total_updwt = total_updwt + updwt  # update total weight of unplanned demand

    print(f"\n//////////////////////////////////////////////////////////////////////")
    print(f"  UPD Pallets Available:             {'{:,}'.format(all_pallets)}")
    print(f"  UPD Weight Available:              {'{:,.2f}'.format(total_updwt)}")
    if mskulist != 0:
        print(f"  MSKUs Excluded:                    {mskulist}")
    # Create winshuttle script excel file
    date = datetime.datetime.today().strftime("%m-%d-%Y")  # mm-dd-yyyy
    # check if this is load_both
    if rerun != 1:
        # file destination select dialogue
        Tk().withdraw()  # prevent root window
        dirspath = filedialog.askdirectory(title='Select the output file save destination')
        dirsavepath = os_split_fixer(dirspath + os.sep + dirname)
        os.mkdir(dirsavepath)
        spath = dirsavepath + os.sep
    # create file name as a variable
    filename = spath + 'Dash STO Planner - FM36 - ' + date + '.xlsx'
    # rewrite filepath with correct operating system separators
    filename = os_split_fixer(filename)
    # create a Pandas Excel writer using XlsxWriter as the engine
    loadsfilewriter = pd.ExcelWriter(filename, engine='xlsxwriter')
    # create workbook and worksheet objects
    loadsworkbook = loadsfilewriter.book
    worksheet = loadsworkbook.add_worksheet('Script')
    # create worksheet objects to save each dataframe to
    analystdf.to_excel(loadsfilewriter, engine='xlsxwriter', sheet_name='Analyst', index=False)
    worksheet2 = loadsfilewriter.sheets['Analyst']
    # create formatting methods
    comma_format = loadsworkbook.add_format({'num_format': '#,##0.00', 'align': 'right'})
    prcnt_format = loadsworkbook.add_format({'num_format': '0.00%', 'align': 'right'})
    merge_format = loadsworkbook.add_format({'align': 'center', 'italic': True, 'bold': True})
    right_format = loadsworkbook.add_format({'align': 'right'})
    left_format = loadsworkbook.add_format({'align': 'left'})
    center_format = loadsworkbook.add_format({'align': 'center'})
    bold_format = loadsworkbook.add_format({'bold': True, 'align': 'center'})
    # formats for conditional formatting
    bad_format = loadsworkbook.add_format({'bg_color': '#FFC7CE', 'font_color': '#9C0006'})
    good_format = loadsworkbook.add_format({'bg_color': '#C6EFCE', 'font_color': '#006100'})
    # write workbook headers for script output
    worksheet.write(0, 0, 'RUN LOG', bold_format)  # cell A1
    worksheet.write(0, 1, 'Analyst', bold_format)  # cell B1
    worksheet.write(0, 2, 'Delivery', bold_format)  # cell C1
    worksheet.write(1, 2, 1)  # cell C2
    worksheet.write(0, 3, 'Select Date', bold_format)  # cell D1
    worksheet.write(0, 4, 'Sales Order', bold_format)  # cell E1
    worksheet.write(0, 5, 'Line Item 1', bold_format)  # cell F1
    worksheet.write(0, 6, 'Line Item 2', bold_format)  # cell G1
    worksheet.write(0, 7, 'MSKU', bold_format)  # cell H1
    worksheet.write(0, 8, 'Units', bold_format)  # cell I1
    worksheet.write(0, 9, 'Plan Date', bold_format)  # cell J1
    worksheet.write(0, 10, 'Order ID', bold_format)  # cell K1
    worksheet.write(0, 11, 'Gross Wt', bold_format)  # cell L1
    worksheet.write(0, 12, 'Start ToFill', bold_format)  # cell M1
    worksheet.write(0, 13, 'Wt Assigned', bold_format)  # cell N1
    worksheet.write(0, 14, 'Plts Assigned', bold_format)  # cell O1
    worksheet.write(0, 15, 'New ToFill', bold_format)  # cell P1
    worksheet.write(0, 16, 'Target Met', bold_format)  # cell Q1
    worksheet.merge_range('R1:S1', 'Dash Planner Filled Results', merge_format)
    worksheet.write(0, 19, 'Order', bold_format)  # cell T1
    worksheet.write(0, 20, 'Status', bold_format)  # cell U1
    worksheet.write(0, 21, 'Lines', bold_format)  # cell V1
    worksheet.write(0, 22, 'Wt Rem', bold_format)  # cell W1
    worksheet.write(0, 23, 'Fill %', bold_format)  # cell X1
    worksheet.write(0, 24, 'Plts Assigned', bold_format)  # cell Y1
    # write summary results
    worksheet.write(1, 17, 'Total Pllts Assigned')  # cell S2
    worksheet.write(1, 18, '=SUMIFS($O:$O,$Q:$Q,1)', comma_format)  # cell T2
    worksheet.write(2, 17, 'Total Wt Assigned')  # cell S3
    worksheet.write(2, 18, '=SUMIFS($N:$N,$Q:$Q,1)', comma_format)  # cell T3
    worksheet.write(3, 17, 'Filled Orders Created')  # cell S4
    worksheet.write(3, 18, '=COUNTIFS($U:$U,"Filled")')  # cell T4
    worksheet.write(4, 17, 'Avg Start ToFill')  # cell S5
    worksheet.write(4, 18, '=AVERAGE($L:$L)', comma_format)  # cell T5
    worksheet.write(5, 17, 'Avg Wt Remaining')  # cell S6
    worksheet.write(5, 18, '=AVERAGEIFS($W:$W,$U:$U,"Filled")', comma_format)  # cell T6
    worksheet.write(6, 17, 'Avg Wt Filled')  # cell S7
    worksheet.write(6, 18, '=$S$5-$S$6', comma_format)  # cell T7
    worksheet.write(7, 17, 'Avg Filled Order %')  # cell S8
    worksheet.write(7, 18, '=IFERROR(AVERAGEIFS($X:$X,$U:$U,"Filled"),"-")', prcnt_format)  # cell T8
    worksheet.write(8, 17, 'Execution Time')  # cell S9
    worksheet.write(9, 17, 'Total UPD Wt Available')  # cell S10
    worksheet.write(9, 18, total_updwt, comma_format)  # cell T10
    worksheet.write(10, 17, 'Total UPD % Assigned')  # cell S11
    worksheet.write(10, 18, '=$S$3/$S$10', prcnt_format)  # cell T11
    # set column widths by range for worksheet
    worksheet.set_column(0, 0, 40)  # A:A
    worksheet.set_column(1, 1, 23)  # B:B
    worksheet.set_column(2, 13, 11)  # C:N
    worksheet.set_column(14, 14, 12)  # O:O
    worksheet.set_column(15, 16, 11)  # P:R
    worksheet.set_column(17, 17, 21)  # R:R
    worksheet.set_column(18, 18, 13.5)  # S:S
    worksheet.set_column(19, 23, 10)  # T:X
    worksheet.set_column(24, 24, 12)  # Y:Y
    # set column widths by range for worksheet2
    worksheet2.set_column(0, 0, 12)  # A:A
    worksheet2.set_column(1, 1, 23)  # B:B
    # Start the main assignment loop
    row = 1  # set starting row
    print(f"\n//////////////////////////////////////////////////////////////////////")
    print(f"  Beginning unplanned demand assignment")
    # start timer
    a_begin_time = datetime.datetime.now()
    print(f"  Start time:                        {a_begin_time}")
    # create pallet counting variable
    tot_pal_added = 0
    # calculate day range window
    day_window = dynamicdayrange()
    dayrange = day_window[0]
    # loop through list of new orders to make
    for new_order_id in new_order_ids:
        # loop through dictionary of loads to work on
        for lane, load in loads.items():
            # grab values from dictionary list
            lsource_id = lane  # Source ID
            gross_wt = 0  # Gross Wt
            to_fill = load[0]  # Target full truck weight
            # convert plan date to timestamp
            plan_date = pd.to_datetime(plan_date)
            # format as mm/dd/yyyy
            plan_date = plan_date.strftime('%m/%d/%Y')
            # calc plan date position in list
            dayindex = dayrange.index(plan_date) + 1
            # calculate selection date - Today + 1 year
            today_date = datetime.datetime.today()  # return today's date
            n_year_today = today_date + datetime.timedelta(days=365)  # calculate next year today
            s_date = n_year_today.strftime('%m/%d/%Y')  # format as mm/dd/yyyy
            if lsource_id == new_order_id:
                # for each load, loop through dictionary of UPD available to find assignment matches
                for demand, order in orders.items():
                    usource_id = order[0]  # order source_id
                    order_week = order[1]  # sales order week
                    origin = order[2]  # origin plant
                    msku = order[7]  # msku
                    uatp_id = str(str(origin) + '-' + str(msku))  # plant + msku
                    so = order[8]  # sales order
                    line = order[9]  # sales order line item
                    unit_wt = order[10]  # unit weight
                    u_p_pal = order[11]  # units per pallet
                    pallets = order[12]  # pallets
                    pallet_wt = unit_wt * u_p_pal  # pallet weight
                    # make assignment if source_ids match
                    if lsource_id == usource_id:
                        # loop into gatp dictionary
                        for pair, gatp in gatps.items():
                            # trim list to only days inventory can be assigned to the Delivery
                            avail_inv = list(gatp[:dayindex])
                            # get max available inventory from subindexed gatp list
                            atp = max(avail_inv, default=0)
                            # make assignment if gatp_ids match and there is product available
                            if uatp_id == pair and atp > 0:
                                # get projected inventory limit from dictionary
                                for projipair, proji in projis.items():
                                    # find gATP match in both available QTY and projected inventory dictionaries
                                    if projipair == uatp_id:
                                        # get proj inv limit and proj inv week to adjust (if any)
                                        weekcheck_limitlist = weekcheck_limiter(list(proji), plan_date, order_week)
                                        projiwklimit = weekcheck_limitlist[0]  # proj inv limit
                                        projiwk_to_adj = weekcheck_limitlist[1]  # proj inv week to adjust
                                        # calculate how much UPD to assign using the assign() function
                                        assigned = assign(target=to_fill, p_wt=pallet_wt, t_plt=pallets,
                                                          u_plt=u_p_pal, atp=atp, pi_limit=projiwklimit)
                                        # [t_plt, filled, n_target, atp] output list from assign() function
                                        tot_plt = assigned[0]  # total pallets assigned
                                        a_filled = assigned[1]  # weight assigned
                                        n_to_fill = assigned[2]  # new to fill target
                                        units = tot_plt * u_p_pal  # calc units were assigned
                                        # if units were assigned
                                        if units > 0:
                                            # update orders dictionary with new pallets available
                                            order[12] = pallets - tot_plt  # new pallets available
                                            # add number of pallets added to running total variable
                                            tot_pal_added = tot_pal_added + tot_plt
                                            # store to fill before assignment
                                            orig_to_fill = to_fill  # to fill before assignment
                                            # update to fill amount with new target to fill amount
                                            to_fill = n_to_fill  # lower to fill by more amount assigned
                                            # update gatps dictionary with new inventory available
                                            futurefixer(gatp, units)
                                            # adjust projected inventory if needed
                                            if projiwk_to_adj == 'week 1':
                                                # update proji dictionary for week 1
                                                proji[0] = proji[0] - units
                                            elif projiwk_to_adj == 'week 2':
                                                # update proji dictionary for week 2
                                                proji[1] = proji[1] - units
                                            elif projiwk_to_adj == 'both':
                                                # update proji dictionary for both week 1 and week 2
                                                proji[0] = proji[0] - units
                                                proji[1] = proji[1] - units
                                            # print results in next row of script file
                                            # worksheet.write(row, 2, delivery)  # column C - Delivery
                                            worksheet.write(row, 3, s_date, center_format)  # column D - Select Date
                                            worksheet.write(row, 4, so)  # column E - Sales Order
                                            worksheet.write(row, 5, line)  # column F - Line Item
                                            worksheet.write(row, 6, line)  # column G - Line Item
                                            worksheet.write(row, 7, msku)  # column H - MSKU
                                            worksheet.write(row, 8, units, right_format)  # column I - Units
                                            worksheet.write(row, 9, plan_date, center_format)  # column J - Plan Date
                                            worksheet.write(row, 10, usource_id, center_format)  # column K - Order ID
                                            worksheet.write(row, 11, gross_wt, comma_format)  # column L - Gross Wt
                                            worksheet.write(row, 12, orig_to_fill,
                                                            comma_format)  # column M - Start ToFill
                                            worksheet.write(row, 13, a_filled, comma_format)  # column N - Wt Assigned
                                            worksheet.write(row, 14, tot_plt, right_format)  # column O - Plts Assigned
                                            worksheet.write(row, 15, to_fill, comma_format)  # column P - New ToFill
                                            # increase row index
                                            row += 1
                                        else:
                                            # if no units are assigned continue to next line
                                            continue
                                    else:
                                        # if atp_ids do not match continue to next line
                                        continue
                            else:
                                # if gatp ids do not match continue to next line
                                continue
                    else:
                        # if source ids do not match continue to next line
                        continue
                # add weight remaining to load list
                load.append(to_fill)
                # add new element to load list to track is load created is under cutoff
                if to_fill <= cutoff:
                    load.append(1)  # add TRUE boolean to indicate success
                else:
                    load.append(0)  # add FALSE boolean to indicate failure
    # Main Loop Wrap Up
    row += 1  # increase row index final time
    # distinguish variables to prevent continuity issues
    row1 = row
    row2 = row
    row5 = row - 1
    row6 = row
    row7 = row
    row8 = row
    row9 = row
    print(f"  Dash Planning completed")
    print(f"  Entering formulas")
    # input formula for column c starting in cell B2
    for i in range(2, row1):
        # =IFERROR(VLOOKUP(VALUE(RIGHT($K2,FIND("-",$K2)+1)),Analyst!$A:$B,2,FALSE),"-")
        inp_cell = 'B' + str(i)
        cell1 = '$K' + str(i)
        formula = '=IFERROR(VLOOKUP(VALUE(RIGHT(' + cell1 + ',FIND("-",' + cell1 + ')-1)),Analyst!$A:$B,2,FALSE),"-")'
        # input string as formula
        worksheet.write_formula(inp_cell, formula, left_format)

    # input formula for column c starting in cell C3
    for i in range(3, row1):
        # =IF(AND(P2>P3,K3=K2),C2,C2+1)
        inp_cell = 'C' + str(i)
        cell1 = 'P' + str(i - 1)
        cell2 = 'P' + str(i)
        cell3 = 'K' + str(i)
        cell4 = 'K' + str(i - 1)
        cell5 = 'C' + str(i - 1)
        formula = '=IF(AND(' + cell1 + '>' + cell2 + ',' + cell3 + '=' + cell4 + '),' + cell5 + ',' + cell5 + '+1)'
        # input string as formula
        worksheet.write_formula(inp_cell, formula)

    # input formula for column c starting in cell L2
    for i in range(2, row1):
        # =IFERROR(VLOOKUP($C3,$C:$M,11,FALSE),"-")
        inp_cell = 'L' + str(i)
        cell1 = '$C' + str(i)
        formula = '=IFERROR(VLOOKUP(' + cell1 + ',$C:$M,11,FALSE),"-")'
        # input string as formula
        worksheet.write_formula(inp_cell, formula, comma_format)

    # input formula for column n starting in cell Q2
    for i in range(2, row2):
        # =IF(LOOKUP($C2,$C:$P)<=(1-{cutoff})*$L2,1,0)
        inp_cell = 'Q' + str(i)
        cell1 = '$C' + str(i)
        cell2 = '$L' + str(i)
        formula = '=IF(LOOKUP(' + cell1 + ',$C:$P)<=(1-' + str(cutoff) + ')*' + cell2 + ',1,0)'
        # input string as formula
        worksheet.write_formula(inp_cell, formula)

    # input load completion count list starting in cell T2
    l_comp = 1
    for i in range(1, row5):
        # inp_cell = 'T' + str(i)
        # worksheet.write_formula(inp_cell, l_comp1)
        worksheet.write(i, 19, l_comp, left_format)
        l_comp += 1

    # input formula for column r starting in cell U2
    for i in range(2, row6):
        # =IF(T2>{last cell in C},"-",IF(VLOOKUP($T2,$C:$Q,15,FALSE)=1,"Filled", "Light"))
        inp_cell = 'U' + str(i)
        cell1 = '$T' + str(i)
        cell2 = '$C$' + str(row1 - 1)
        formula = '=IF(' + cell1 + '>' + cell2 + ',"-",IF(VLOOKUP(' + cell1 + ',$C:$Q,15,FALSE)=1,"Filled", "Light"))'
        # input string as formula
        worksheet.write_formula(inp_cell, formula)

    # input formula for column s starting in cell V2
    for i in range(2, row7):
        # =IF($U2="-","-",COUNTIF($C:$C,$T2))
        inp_cell = 'V' + str(i)
        cell1 = 'U' + str(i)
        cell2 = 'T' + str(i)
        formula = '=IF($' + cell1 + '="-","-",COUNTIF($C:$C,$' + cell2 + '))'
        # input string as formula
        worksheet.write_formula(inp_cell, formula, right_format)

    # input formula for column s starting in cell W2
    for i in range(2, row8):
        # =IFERROR(INDEX($C:$P,MATCH($T2,$C:$C,0)+$V2-1,14),"-")
        inp_cell = 'W' + str(i)
        cell1 = 'T' + str(i)
        cell2 = 'V' + str(i)
        formula = '=IFERROR(INDEX($C:$P,MATCH($' + cell1 + ',$C:$C,0)+$' + cell2 + '-1,14),"-")'
        # input string as formula
        worksheet.write_formula(inp_cell, formula, comma_format)

    # input formula for column s starting in cell X2
    for i in range(2, row8):
        # =IFERROR(1-($W2/VLOOKUP($T2,$C:$M,11,FALSE)),"-")
        inp_cell = 'X' + str(i)
        cell1 = '$W' + str(i)
        cell2 = '$T' + str(i)
        formula = '=IFERROR(1-(' + cell1 + '/VLOOKUP(' + cell2 + ',$C:$M,11,FALSE)),"-")'
        # input string as formula
        worksheet.write_formula(inp_cell, formula, prcnt_format)

    # input formula for column s starting in cell Y2
    for i in range(2, row9):
        # =IF(COUNTIFS($O:$O,$T2)=0,"-",COUNTIFS($O:$O,$T2))
        inp_cell = 'Y' + str(i)
        cell1 = 'T' + str(i)
        formula = '=IF(COUNTIFS($O:$O,$' + cell1 + ')=0,"-",COUNTIFS($O:$O,$' + cell1 + '))'
        # input string as formula
        worksheet.write_formula(inp_cell, formula, right_format)

    warnings.simplefilter('ignore')  # turn off warnings
    # set conditional formatting on planned order results
    cfrng = 'U2:U' + str(row9 - 1)
    worksheet.conditional_format(cfrng, {'type': 'cell', 'criteria': '==', 'value': '"Light"', 'format': bad_format})
    worksheet.conditional_format(cfrng, {'type': 'cell', 'criteria': '==', 'value': '"Filled"', 'format': good_format})
    # conditional format with data bars for formula range in column X
    x_range = 'X2:X' + str(row9 - 1)
    worksheet.conditional_format(x_range, {'type': 'data_bar', 'bar_border_color': '091F3F', 'bar_color': 'D8E0E4'})
    warnings.simplefilter("default")    # turn warnings back on
    # Calculate totals for final results in load_filler
    print(f"  Totaling unplanned demand assigned")
    # create new variable to sum remaining pallets
    count_pallets = 0
    # loop into orders dictionary
    for demand, order in orders.items():
        # get remaining pallets available
        u_pallets = order[12]
        # add pallets available to running total variable
        count_pallets = count_pallets + u_pallets

    print(f"  Assignment completed")
    # print execution time
    a_end_time = datetime.datetime.now()
    assign_time = a_end_time - a_begin_time
    e_assign_time = str(assign_time)
    print(f"  Assign time:                        {assign_time}")
    # add in results fields to cell T9
    worksheet.write(8, 18, e_assign_time)
    # close created workbook
    loadsfilewriter.close()
    print(f"  End time:                           {a_end_time}")
    # calc results
    print(f"\n//////////////////////////////////////////////////////////////////////")
    # start timer
    r_begin_time = datetime.datetime.now()
    print(f"  Calculating results")
    print(f"  Start time:                         {r_begin_time}")
    # calculate results and create UPD remaining output
    upd_resfiles(orders, mitfile, spath, date)
    # end timer
    r_end_time = datetime.datetime.now()
    # calc duration
    results_time = r_end_time - r_begin_time
    print(f"  End time:                           {r_end_time}")
    print(f"  Results time:                       {results_time}")
    # print total script execution and results time
    s_e_time = datetime.datetime.now()
    t_script_time = s_e_time - s_s_time
    print(f"\n//////////////////////////////////////////////////////////////////////")
    print(f"  Your Winshuttle script has been created successfully!")
    print(f"  Total Dash Filler Unplanned Demand assignment time")
    print(f"  Import Loads data:                  {step1_time}")
    print(f"  Import Orders data:                 {step2_time}")
    print(f"  Import gATP data:                   {step3_time}")
    print(f"  Assignment time:                    {assign_time}")
    print(f"  Results time:                       {results_time}")
    print(f"  Dash Filler execution time:                         {t_script_time}")
    print(f"\n//////////////////////////////////////////////////////////////////////")
    return


def load_both(lwvrfile: str, updrfile: str, gatpfile: str, mitfile: str,
                     dunnage: int, dirname: str, mskulist: list, cutoff: float, plan_date: str):
    """Function that processes through load_filler and delivery_planner"""
    # fill existing loads
    orders, gatps, projis, n_orders, all_orders, t_script_time, spath = load_filler(lwvrfile, updrfile, gatpfile,
                                                                                    mitfile, dunnage, dirname,
                                                                                    mskulist, 1)
    # pass output and use remainder to create new loads
    delivery_planner(lwvrfile, updrfile, gatps, mitfile, dunnage, dirname,
                     mskulist, cutoff, plan_date, orders, projis, 1, spath)
    return


def sto_load_both(lwvrfile: str, updrfile: str, gatpfile: str, mitfile: str,
                     dunnage: int, dirname: str, mskulist: list, cutoff: float, plan_date: str):
    """Function that processes through load_filler and delivery_planner"""
    # fill existing sto
    orders, gatps, projis, n_orders, all_orders, t_script_time, spath = sto_load_filler(lwvrfile, updrfile, gatpfile,
                                                                                        mitfile, dunnage, dirname,
                                                                                        mskulist, 1)
    # pass output and use remainder to create new stos
    sto_planner(lwvrfile, updrfile, gatps, mitfile, dunnage, dirname,
                mskulist, cutoff, plan_date, orders, projis, 1, spath)
    return


def onclick():
    pass
    return


def open_lwvr():
    """Select Load Weight Variance Report file"""
    Tk().withdraw()  # prevent root window
    global lwvrfilenamex
    lwvrfilenamex = askopenfilename(title='Select a Load Weight Filler Report',
                                    filetypes=[('Excel files', '.xlsx .xls')])
    if lwvrfilenamex != '':
        label1 = 'File selected'
        upd_label1(label1)
    else:
        label1 = 'Select a Load Weight Filler Report'
        upd_label1(label1)
    return lwvrfilenamex, label1


def open_updr():
    """Select Unplanned Demand Report file"""
    Tk().withdraw()  # prevent root window
    global updrfilenamex
    updrfilenamex = askopenfilename(title='Select a Requirements View Report',
                                    filetypes=[('Excel files', '.xlsx .xls')])
    if updrfilenamex != '':
        label2 = 'File selected'
        upd_label2(label2)
    else:
        label2 = 'Select a Requirements View Report'
        upd_label2(label2)
    return updrfilenamex, label2


def open_gatp():
    """Select a gATP Availability file"""
    Tk().withdraw()  # prevent root window
    global gatpfilenamex
    # open file explorer window to select file
    gatpfilenamex = askopenfilename(title='Select an Inventory Flow Report', filetypes=[('Excel files', '.xlsx .xls')])
    if gatpfilenamex != '':
        label3 = 'File selected'
        upd_label3(label3)
    else:
        label3 = 'Select an Inventory Flow Report'
        upd_label3(label3)
    return gatpfilenamex, label3


def open_mit():
    """Select a Material Information Tool report"""
    Tk().withdraw()  # prevent root window
    global mitfilenamex
    mitfilenamex = askopenfilename(title='Select a Material Information Tool Report',
                                   filetypes=[('Excel files', '.xlsx .xls')])
    return mitfilenamex


def upd_label1(txt):
    """Function to label 1"""
    label1.set(txt)
    return


def upd_label2(txt):
    """Function to label 2"""
    label2.set(txt)
    return


def upd_label3(txt):
    """Function to label 3"""
    label3.set(txt)
    return


def service_disabler():
    if chbox1.get() == 0:
        e1.configure(state='disabled')
        e2.configure(state='disabled')
        optbtn2.configure(state='disabled', bg='#D8E0E4')
        optbtn3.configure(state='disabled', bg='#D8E0E4')
        lfroot.update_idletasks()
    else:
        e1.configure(state='normal')
        e2.configure(state='normal')
        optbtn2.configure(state='normal', bg='#FFB000')
        optbtn3.configure(state='normal', bg='#FFB000')
        lfroot.update_idletasks()
    return


def socmir_round_btn():
    """Function that feeds reports into socmir_round"""
    if updrfilenamex == '' or mitfilenamex == '':
        ctypes.windll.user32.MessageBoxW(0, 'Please select a Requirements View and MIT file for processing.',
                                         'Files not selected', 0)
    else:
        # process cmir rounding function
        socmir_round(updrfilenamex, mitfilenamex)
        ctypes.windll.user32.MessageBoxW(0, 'Your new file has been completed successfully!',
                                         'SO CMIR Completed', 0)
    return


def open_filling_menu():
    """From main menu open the filling menu and close main menu"""
    mainroot.destroy()
    filling_menu()
    return


def open_ewm_filling_menu():
    """From main menu open the filling menu and close main menu"""
    mainroot.destroy()
    ewm_filling_menu()
    return


def open_sto_filling_menu():
    """From main menu open the filling menu and close main menu"""
    mainroot.destroy()
    sto_filling_menu()
    return


def open_filling_menu_from_mskufilling():
    """From msku filling menu re-open the filling menu and close msku filling menu"""
    mskurootfilling.destroy()  # destroy MSKUs to remove window
    filling_menu()  # open filling menu
    return


def open_sto_filling_menu_from_mskufilling():
    """From msku STO filling menu re-open the STO filling menu and close msku STO filling menu"""
    sto_mskurootfilling.destroy()  # destroy MSKUs to remove window
    sto_filling_menu()  # open filling menu
    return


def service_menu_back():
    lfroot.destroy()
    main_menu()
    return


def load_filler_btn():
    """Function that feeds reports into load_filler"""
    dunnage = int(e3.get())  # get the value of entry box 3
    global mskus_to_remove
    if mskus_to_remove == '':
        mskus_to_remove = 0
    if lwvrfilenamex == '' or updrfilenamex == '' or gatpfilenamex == '':
        ctypes.windll.user32.MessageBoxW(0, 'Please select all files needed for processing.', 'Files not selected', 0)
    elif mitfilenamex == '':
        ctypes.windll.user32.MessageBoxW(0, 'Please select an MIT file for processing.', 'MIT not selected', 0)
    elif str(erunname.get()) == '':
        # get current date to name directory output name
        dirname = datetime.datetime.today().strftime("%Y-%m%d-%H%M")  # ex 2021-0210-2322
        load_filler(lwvrfilenamex, updrfilenamex, gatpfilenamex, mitfilenamex, dunnage, dirname, mskus_to_remove, 0)
        ctypes.windll.user32.MessageBoxW(0, 'Your new file has been completed successfully!',
                                         'Dash Filler Completed', 0)
    else:
        runname = str(erunname.get())
        runname = re.sub(r"\\", "-", runname)
        runname = re.sub(r"/", "-", runname)
        dirname = runname  # set directory output name equal to runname selected by processor
        load_filler(lwvrfilenamex, updrfilenamex, gatpfilenamex, mitfilenamex, dunnage, dirname, mskus_to_remove, 0)
        ctypes.windll.user32.MessageBoxW(0, 'Your new file has been completed successfully!',
                                         'Dash Filler Completed', 0)
    return


def ewm_load_filler_btn():
    """Function that feeds reports into ewm_load_filler"""
    dunnage = int(e3.get())  # get the value of entry box 3
    global mskus_to_remove
    if mskus_to_remove == '':
        mskus_to_remove = 0
    if lwvrfilenamex == '' or updrfilenamex == '' or gatpfilenamex == '':
        ctypes.windll.user32.MessageBoxW(0, 'Please select all files needed for processing.', 'Files not selected', 0)
    elif mitfilenamex == '':
        ctypes.windll.user32.MessageBoxW(0, 'Please select an MIT file for processing.', 'MIT not selected', 0)
    elif str(erunname.get()) == '':
        # get current date to name directory output name
        dirname = datetime.datetime.today().strftime("%Y-%m%d-%H%M")  # ex 2021-0210-2322
        ewm_load_filler(lwvrfilenamex, updrfilenamex, gatpfilenamex, mitfilenamex, dunnage, dirname, mskus_to_remove, 0)
        ctypes.windll.user32.MessageBoxW(0, 'Your new file has been completed successfully!',
                                         'Dash Filler Completed', 0)
    else:
        runname = str(erunname.get())
        runname = re.sub(r"\\", "-", runname)
        runname = re.sub(r"/", "-", runname)
        dirname = runname  # set directory output name equal to runname selected by processor
        ewm_load_filler(lwvrfilenamex, updrfilenamex, gatpfilenamex, mitfilenamex, dunnage, dirname, mskus_to_remove, 0)
        ctypes.windll.user32.MessageBoxW(0, 'Your new file has been completed successfully!',
                                         'Dash Filler Completed', 0)
    return


def sto_load_filler_btn():
    """Function that feeds reports into sto_load_filler"""
    dunnage = int(e3.get())  # get the value of entry box 3
    global mskus_to_remove
    if mskus_to_remove == '':
        mskus_to_remove = 0
    if lwvrfilenamex == '' or updrfilenamex == '' or gatpfilenamex == '':
        ctypes.windll.user32.MessageBoxW(0, 'Please select all files needed for processing.', 'Files not selected', 0)
    elif mitfilenamex == '':
        ctypes.windll.user32.MessageBoxW(0, 'Please select an MIT file for processing.', 'MIT not selected', 0)
    elif str(erunname.get()) == '':
        # get current date to name directory output name
        dirname = datetime.datetime.today().strftime("%Y-%m%d-%H%M")  # ex 2021-0210-2322
        sto_load_filler(lwvrfilenamex, updrfilenamex, gatpfilenamex, mitfilenamex, dunnage, dirname, mskus_to_remove, 0)
        ctypes.windll.user32.MessageBoxW(0, 'Your new file has been completed successfully!',
                                         'Dash Filler Completed', 0)
    else:
        runname = str(erunname.get())
        runname = re.sub(r"\\", "-", runname)
        runname = re.sub(r"/", "-", runname)
        dirname = runname  # set directory output name equal to runname selected by processor
        sto_load_filler(lwvrfilenamex, updrfilenamex, gatpfilenamex, mitfilenamex, dunnage, dirname, mskus_to_remove, 0)
        ctypes.windll.user32.MessageBoxW(0, 'Your new file has been completed successfully!',
                                         'Dash Filler Completed', 0)
    return


def del_planner_btn():
    """Function that feeds reports into delivery_planner"""
    p_date = str(e1.get())  # get the value of entry box 1
    cutoff = float(e2.get())  # get the value of entry box 2
    dunnage = int(e3.get())  # get the value of entry box 3
    global mskus_to_remove
    if mskus_to_remove == '':
        mskus_to_remove = 0
    if lwvrfilenamex == '' or updrfilenamex == '' or gatpfilenamex == '':
        ctypes.windll.user32.MessageBoxW(0, 'Please select all files needed for processing.', 'Files not selected', 0)
    elif mitfilenamex == '':
        ctypes.windll.user32.MessageBoxW(0, 'Please select an MIT file for processing.', 'MIT not selected', 0)
    elif str(erunname.get()) == '':
        # get current date to name directory output name
        dirname = datetime.datetime.today().strftime("%Y-%m%d-%H%M")  # ex 2021-0210-2322
        delivery_planner(lwvrfilenamex, updrfilenamex, gatpfilenamex, mitfilenamex,
                         dunnage, dirname, mskus_to_remove, cutoff, p_date, 0, 0, 0, '-')
        ctypes.windll.user32.MessageBoxW(0, 'Your new file has been completed successfully!',
                                         'Dash Filler Completed', 0)
    else:
        runname = str(erunname.get())
        runname = re.sub(r"\\", "-", runname)
        runname = re.sub(r"/", "-", runname)
        dirname = runname  # set directory output name equal to runname selected by processor
        delivery_planner(lwvrfilenamex, updrfilenamex, gatpfilenamex, mitfilenamex,
                         dunnage, dirname, mskus_to_remove, cutoff, p_date, 0, 0, 0, '-')
        ctypes.windll.user32.MessageBoxW(0, 'Your new file has been completed successfully!',
                                         'Dash Filler Completed', 0)
    return


def sto_planner_btn():
    """Function that feeds reports into delivery_planner"""
    p_date = str(e1.get())  # get the value of entry box 1
    cutoff = float(e2.get())  # get the value of entry box 2
    dunnage = int(e3.get())  # get the value of entry box 3
    global mskus_to_remove
    if mskus_to_remove == '':
        mskus_to_remove = 0
    if lwvrfilenamex == '' or updrfilenamex == '' or gatpfilenamex == '':
        ctypes.windll.user32.MessageBoxW(0, 'Please select all files needed for processing.', 'Files not selected', 0)
    elif mitfilenamex == '':
        ctypes.windll.user32.MessageBoxW(0, 'Please select an MIT file for processing.', 'MIT not selected', 0)
    elif str(erunname.get()) == '':
        # get current date to name directory output name
        dirname = datetime.datetime.today().strftime("%Y-%m%d-%H%M")  # ex 2021-0210-2322
        sto_planner(lwvrfilenamex, updrfilenamex, gatpfilenamex, mitfilenamex,
                         dunnage, dirname, mskus_to_remove, cutoff, p_date, 0, 0, 0, '-')
        ctypes.windll.user32.MessageBoxW(0, 'Your new file has been completed successfully!',
                                         'Dash Filler Completed', 0)
    else:
        runname = str(erunname.get())
        runname = re.sub(r"\\", "-", runname)
        runname = re.sub(r"/", "-", runname)
        dirname = runname  # set directory output name equal to runname selected by processor
        sto_planner(lwvrfilenamex, updrfilenamex, gatpfilenamex, mitfilenamex,
                         dunnage, dirname, mskus_to_remove, cutoff, p_date, 0, 0, 0, '-')
        ctypes.windll.user32.MessageBoxW(0, 'Your new file has been completed successfully!',
                                         'Dash Filler Completed', 0)
    return


def load_both_btn():
    """Function that feeds reports into load_filler and then carries over to delivery_planner"""
    p_date = str(e1.get())  # get the value of entry box 1
    cutoff = float(e2.get())  # get the value of entry box 2
    dunnage = int(e3.get())  # get the value of entry box 3
    global mskus_to_remove
    if mskus_to_remove == '':
        mskus_to_remove = 0
    if lwvrfilenamex == '' or updrfilenamex == '' or gatpfilenamex == '':
        ctypes.windll.user32.MessageBoxW(0, 'Please select all files needed for processing.', 'Files not selected', 0)
    elif mitfilenamex == '':
        ctypes.windll.user32.MessageBoxW(0, 'Please select an MIT file for processing.', 'MIT not selected', 0)
    elif str(erunname.get()) == '':
        # get current date to name directory output name
        dirname = datetime.datetime.today().strftime("%Y-%m%d-%H%M")  # ex 2021-0210-2322
        load_both(lwvrfilenamex, updrfilenamex, gatpfilenamex, mitfilenamex,
                  dunnage, dirname, mskus_to_remove, cutoff, p_date)
        ctypes.windll.user32.MessageBoxW(0, 'Your new file has been completed successfully!',
                                         'Dash Filler Completed', 0)
    else:
        runname = str(erunname.get())
        runname = re.sub(r"\\", "-", runname)
        runname = re.sub(r"/", "-", runname)
        dirname = runname  # set directory output name equal to runname selected by processor
        load_both(lwvrfilenamex, updrfilenamex, gatpfilenamex, mitfilenamex,
                  dunnage, dirname, mskus_to_remove, cutoff, p_date)
        ctypes.windll.user32.MessageBoxW(0, 'Your new file has been completed successfully!',
                                         'Dash Filler Completed', 0)
    return


def sto_load_both_btn():
    """Function that feeds reports into load_filler and then carries over to delivery_planner"""
    p_date = str(e1.get())  # get the value of entry box 1
    cutoff = float(e2.get())  # get the value of entry box 2
    dunnage = int(e3.get())  # get the value of entry box 3
    global mskus_to_remove
    if mskus_to_remove == '':
        mskus_to_remove = 0
    if lwvrfilenamex == '' or updrfilenamex == '' or gatpfilenamex == '':
        ctypes.windll.user32.MessageBoxW(0, 'Please select all files needed for processing.', 'Files not selected', 0)
    elif mitfilenamex == '':
        ctypes.windll.user32.MessageBoxW(0, 'Please select an MIT file for processing.', 'MIT not selected', 0)
    elif str(erunname.get()) == '':
        # get current date to name directory output name
        dirname = datetime.datetime.today().strftime("%Y-%m%d-%H%M")  # ex 2021-0210-2322
        sto_load_both(lwvrfilenamex, updrfilenamex, gatpfilenamex, mitfilenamex,
                      dunnage, dirname, mskus_to_remove, cutoff, p_date)
        ctypes.windll.user32.MessageBoxW(0, 'Your new file has been completed successfully!',
                                         'Dash Filler Completed', 0)
    else:
        runname = str(erunname.get())
        runname = re.sub(r"\\", "-", runname)
        runname = re.sub(r"/", "-", runname)
        dirname = runname  # set directory output name equal to runname selected by processor
        sto_load_both(lwvrfilenamex, updrfilenamex, gatpfilenamex, mitfilenamex,
                      dunnage, dirname, mskus_to_remove, cutoff, p_date)
        ctypes.windll.user32.MessageBoxW(0, 'Your new file has been completed successfully!',
                                         'Dash Filler Completed', 0)
    return


def mskurootfilling_submit():
    global mskus_to_remove
    mskurootfilling.update_idletasks()
    mskufillavoid = str(mskuentry.get())  # get the value of the entry box for MSKUs to remove
    mskus_to_remove = msku_list_splitter(mskufillavoid)  # separate entry box string into list elements
    mskurootfilling.destroy()  # destroy MSKUs to remove window
    return


def sto_mskurootfilling_submit():
    global mskus_to_remove
    sto_mskurootfilling.update_idletasks()
    mskufillavoid = str(mskuentry.get())  # get the value of the entry box for MSKUs to remove
    mskus_to_remove = msku_list_splitter(mskufillavoid)  # separate entry box string into list elements
    sto_mskurootfilling.destroy()  # destroy MSKUs to remove window
    return


def mskufilling_menu():
    # create main menu window
    lfht = 150  # golden rectangle ratio -> 1:1.61
    lfwt = 400  # golden rectangle ratio -> 1:1.61
    bht = 1  # button height
    bwt = 10  # button width
    # ----- create root window
    global mskurootfilling
    mskurootfilling = tk.Tk()
    # Gets the requested values of the height and width
    windowWidth = mskurootfilling.winfo_reqwidth()
    windowHeight = mskurootfilling.winfo_reqheight()
    # Gets both half the screen width/height and window width/height
    positionRight = int(mskurootfilling.winfo_screenwidth() / 2 - windowWidth / 2)
    positionDown = int(mskurootfilling.winfo_screenheight() / 2 - windowHeight / 2)
    positionRight = int(positionRight - (windowWidth / 2))
    positionDown = int(positionDown - (windowHeight * .75))
    # Positions the window in the center of the page.
    mskurootfilling.geometry("+{}+{}".format(positionRight, positionDown))
    # name window
    mskurootfilling.title(apptitle)
    mc_icon = resource_path('mc_icon.ico')
    # mc_icon = resource_path('C:\\Users\\JSVAR\\PycharmProjects\\Language\\mc_icon.ico')
    mskurootfilling.iconbitmap(mc_icon)
    # create gui canvas
    maincanvas = tk.Canvas(mskurootfilling, height=lfht, width=lfwt)
    maincanvas.pack()
    # create gui frame
    mmframe = tk.Frame(mskurootfilling, bg='#D8E0E4')
    mmframe.place(relx=0, rely=0, relwidth=1, relheight=1)
    lflabel1 = tk.Label(mskurootfilling, text='MSKUs to Exclude', fg='#091F3F', bg='#D8E0E4',
                        font=('Tuno', 18)).place(x=200, y=10, anchor='n')
    # entry for MSKUs to remove
    global mskuentry
    mskuentryresp = StringVar()
    mskuentry = Entry(mskurootfilling, textvariable=mskuentryresp, width=42, state='normal',
                      justify=LEFT, font=('Century_Gothic', 11))
    mskuentry.place(x=30, y=60)
    mskuentryresp.set('')
    mskuentrybtn = tk.Button(mskurootfilling, text='Submit', width=bwt, height=bht, bg='#1496FF',
                             font=('Tuno', 14), command=mskurootfilling_submit, fg='#091F3F')
    mskuentrybtn.place(x=200, y=100, anchor='n')
    # ----- create window loop
    mskurootfilling.mainloop()
    return


def sto_mskufilling_menu():
    # create main menu window
    lfht = 150  # golden rectangle ratio -> 1:1.61
    lfwt = 400  # golden rectangle ratio -> 1:1.61
    bht = 1  # button height
    bwt = 10  # button width
    # ----- create root window
    global sto_mskurootfilling
    sto_mskurootfilling = tk.Tk()
    # Gets the requested values of the height and width
    windowWidth = sto_mskurootfilling.winfo_reqwidth()
    windowHeight = sto_mskurootfilling.winfo_reqheight()
    # Gets both half the screen width/height and window width/height
    positionRight = int(sto_mskurootfilling.winfo_screenwidth() / 2 - windowWidth / 2)
    positionDown = int(sto_mskurootfilling.winfo_screenheight() / 2 - windowHeight / 2)
    positionRight = int(positionRight - (windowWidth / 2))
    positionDown = int(positionDown - (windowHeight * .75))
    # Positions the window in the center of the page.
    sto_mskurootfilling.geometry("+{}+{}".format(positionRight, positionDown))
    # name window
    sto_mskurootfilling.title(apptitle)
    mc_icon = resource_path('mc_icon.ico')
    # mc_icon = resource_path('C:\\Users\\JSVAR\\PycharmProjects\\Language\\mc_icon.ico')
    sto_mskurootfilling.iconbitmap(mc_icon)
    # create gui canvas
    maincanvas = tk.Canvas(sto_mskurootfilling, height=lfht, width=lfwt)
    maincanvas.pack()
    # create gui frame
    mmframe = tk.Frame(sto_mskurootfilling, bg='#D8E0E4')
    mmframe.place(relx=0, rely=0, relwidth=1, relheight=1)
    lflabel1 = tk.Label(sto_mskurootfilling, text='MSKUs to Exclude', fg='#091F3F', bg='#D8E0E4',
                        font=('Tuno', 18)).place(x=200, y=10, anchor='n')
    # entry for MSKUs to remove
    global mskuentry
    mskuentryresp = StringVar()
    mskuentry = Entry(sto_mskurootfilling, textvariable=mskuentryresp, width=42, state='normal',
                      justify=LEFT, font=('Century_Gothic', 11))
    mskuentry.place(x=30, y=60)
    mskuentryresp.set('')
    mskuentrybtn = tk.Button(sto_mskurootfilling, text='Submit', width=bwt, height=bht, bg='#1496FF',
                             font=('Tuno', 14), command=sto_mskurootfilling_submit, fg='#091F3F')
    mskuentrybtn.place(x=200, y=100, anchor='n')
    # ----- create window loop
    sto_mskurootfilling.mainloop()
    return


def main_menu():
    # create main menu window
    lfht = 500  # golden rectangle ratio -> 1:1.61
    lfwt = 400  # golden rectangle ratio -> 1:1.61
    bht = 2  # button height
    bwt = 30  # button width
    # ----- create root window
    global mainroot
    mainroot = tk.Tk()
    # Gets the requested values of the height and width
    windowWidth = mainroot.winfo_reqwidth()
    windowHeight = mainroot.winfo_reqheight()
    # Gets both half the screen width/height and window width/height
    positionRight = int(mainroot.winfo_screenwidth() / 2 - windowWidth / 2)
    positionDown = int(mainroot.winfo_screenheight() / 2 - windowHeight / 2)
    positionRight = int(positionRight - (windowWidth / 2))
    positionDown = int(positionDown - (windowHeight * .75))
    # Positions the window in the center of the page.
    mainroot.geometry("+{}+{}".format(positionRight, positionDown))
    # name window
    mainroot.title(apptitle)
    mc_icon = resource_path('mc_icon.ico')
    # mc_icon = resource_path('C:\\Users\\JSVAR\\PycharmProjects\\Language\\mc_icon.ico')
    mainroot.iconbitmap(mc_icon)
    # create gui canvas
    maincanvas = tk.Canvas(mainroot, height=lfht, width=lfwt)
    maincanvas.pack()
    # create gui frame
    mmframe = tk.Frame(mainroot, bg='#D8E0E4')
    mmframe.place(relx=0, rely=0, relwidth=1, relheight=1)
    lflabel1 = tk.Label(mainroot, text='Dash Filler', fg='#091F3F', bg='#D8E0E4',
                        font=('Tuno', 32)).place(x=135, y=40, anchor='n')
    lflabel2 = tk.Label(mainroot, text='by joseph arnson', fg='#091F3F', bg='#D8E0E4',
                        font=('Tuno', 13)).place(x=243, y=67, anchor='nw')
    mmb1 = tk.Button(mainroot, text='Order Filling', width=bwt, height=bht, bg='#1496FF',
                     font=('Tuno', 14), command=open_filling_menu, fg='#091F3F').place(x=200, y=125, anchor='n')
    mmb2 = tk.Button(mainroot, text='EWM Filling', width=bwt, height=bht, bg='#1496FF',
                     font=('Tuno', 14), command=open_ewm_filling_menu, fg='#091F3F').place(x=200, y=195, anchor='n')
    mmb3 = tk.Button(mainroot, text='Order Cutting', width=bwt, height=bht, bg='#1496FF',
                     font=('Tuno', 14), fg='#091F3F').place(x=200, y=265, anchor='n')
    mmb4 = tk.Button(mainroot, text='EWM Cutting', width=bwt, height=bht, bg='#1496FF',
                     font=('Tuno', 14), fg='#091F3F').place(x=200, y=335, anchor='n')
    mmb5 = tk.Button(mainroot, text='Supply Planning', width=bwt, height=bht, bg='#1496FF',
                     font=('Tuno', 14), command=open_sto_filling_menu, fg='#091F3F').place(x=200, y=405, anchor='n')
    # ----- create window loop
    mainroot.mainloop()
    return


def filling_menu():
    # ----- main --> define variables
    global lwvrfilename
    global updrfilename
    global gatpfilename
    global mitfilename
    global lwvrfilenamex
    global updrfilenamex
    global gatpfilenamex
    global mitfilenamex
    global mskus_to_remove
    lwvrfilename = ''
    updrfilename = ''
    gatpfilename = ''
    mitfilename = ''
    lwvrfilenamex = ''
    updrfilenamex = ''
    gatpfilenamex = ''
    mitfilenamex = ''
    mskus_to_remove = ''
    lfht = 359  # golden rectangle ratio -> 1:1.61
    lfwt = 790  # golden rectangle ratio -> 1:1.61
    # ----- create widget variables
    border = 10
    bttnht = 5
    bttnwt = 60
    bht = 1  # button height
    bwt = 6  # button width
    # ----- create root window
    global lfroot
    lfroot = tk.Tk()
    # Gets the requested values of the height and width
    windowWidth = lfroot.winfo_reqwidth()
    windowHeight = lfroot.winfo_reqheight()
    # Gets both half the screen width/height and window width/height
    positionRight = int(lfroot.winfo_screenwidth() / 2 - windowWidth / 2)
    positionDown = int(lfroot.winfo_screenheight() / 2 - windowHeight / 2)
    positionRight = int(positionRight - (windowWidth * 1.5))
    positionDown = int(positionDown - (windowHeight / 2))
    # Positions the window in the center of the page.
    lfroot.geometry("+{}+{}".format(positionRight, positionDown))
    # name window
    lfroot.title(apptitle)
    mc_icon = resource_path('mc_icon.ico')
    lfroot.iconbitmap(mc_icon)
    # create gui canvas
    lfcanvas = tk.Canvas(lfroot, height=lfht, width=lfwt)
    lfcanvas.pack()
    # create gui frame
    lfframe = tk.Frame(lfroot, bg='#D8E0E4')
    lfframe.place(relx=0, rely=0, relwidth=1, relheight=1)
    # Frame 1 --> define stringvar labels
    global label1
    label1 = StringVar()
    label1.set('Select a Load Weight Filler Report')
    global label2
    label2 = StringVar()
    label2.set('Select a Requirements View Report')
    global label3
    label3 = StringVar()
    label3.set('Select an Inventory Flow Report')
    # Frame 5
    global label4
    label4 = StringVar()
    label4.set('Select a Requirements View Report')
    global label5
    label5 = StringVar()
    label5.set('Select an MIT Tool Report')
    global label6
    label6 = StringVar()
    label6.set('Select an Inventory Flow Report')
    # ----- Main Window frames and widgets
    finfo = Frame(lfroot, bd=0, height=45, width=225, highlightbackground='#091F3F',
                  highlightcolor='#D8E0E4', highlightthickness=1).place(x=15, y=15)
    fselect = Frame(lfroot, bd=0, height=130, width=375, highlightbackground='#091F3F',
                    highlightcolor='#1496FF', highlightthickness=1).place(x=15, y=74)
    fopts = Frame(lfroot, bd=0, height=130, width=260, highlightbackground='#091F3F',
                  highlightcolor='#091F3F', highlightthickness=1).place(x=405, y=74)
    flogo = Frame(lfroot, bd=0, height=130, width=375, highlightbackground='#091F3F',
                  highlightcolor='#091F3F', highlightthickness=1).place(x=15, y=219)
    fset = Frame(lfroot, bd=0, height=130, width=260, highlightbackground='#091F3F',
                 highlightcolor='#091F3F', highlightthickness=1).place(x=405, y=219)
    frun = Frame(lfroot, bd=0, height=45, width=225, highlightbackground='#091F3F',
                 highlightcolor='#091F3F', highlightthickness=1).place(x=555, y=15)
    lflabel1 = tk.Label(lfroot, text='Dash Filler', fg='#091F3F', bg='#D8E0E4',
                        font=('Tuno', 32)).place(x=270, y=5, anchor='nw')
    fday1 = Frame(lfroot, bd=0, height=40, width=100, highlightbackground='#091F3F',
                  highlightcolor='#091F3F', highlightthickness=1).place(x=680, y=219)
    fday2 = Frame(lfroot, bd=0, height=75, width=100, highlightbackground='#091F3F',
                  highlightcolor='#091F3F', highlightthickness=1).place(x=680, y=274)
    fcmir = Frame(lfroot, bd=0, height=130, width=100, highlightbackground='#091F3F',
                  highlightcolor='#091F3F', highlightthickness=1).place(x=680, y=74)

    # ----- Frame 0
    menu = tk.Button(lfroot, text='Menu', width=bwt, height=bht, bg='#1496FF',
                     font=('Century_Gothic', 12), command=service_menu_back).place(x=30, y=22, anchor='nw')
    mit = tk.Button(lfroot, text='MIT', width=bwt, height=bht, bg='#FFB000',
                    font=('Century_Gothic', 12), command=open_mit).place(x=95, y=22, anchor='nw')
    msku = tk.Button(lfroot, text='MSKU', width=bwt, height=bht, bg='#FF6912',
                     font=('Century_Gothic', 12), command=mskufilling_menu).place(x=160, y=22, anchor='nw')
    # ----- Frame 1 --> Loads
    lwvbtn = Button(lfroot, text='LWF', width=bwt, command=open_lwvr,
                    font=('Century_Gothic', 12), bg='#FFB000', fg='#091F3F').place(x=30, y=90)
    lwvlbl = Label(lfroot, textvariable=label1, font=('Century_Gothic', 11)).place(x=100, y=95)
    # Orders
    updbtn = Button(lfroot, text='REQ', width=bwt, command=open_updr,
                    font=('Century_Gothic', 12), bg='#FFB000', fg='#091F3F').place(x=30, y=122)
    updlbl = Label(lfroot, textvariable=label2, font=('Century_Gothic', 11)).place(x=100, y=127)
    # gATP
    atpbtn = Button(lfroot, text='IFR', width=bwt, command=open_gatp,
                    font=('Century_Gothic', 12), bg='#FFB000', fg='#091F3F').place(x=30, y=154)
    l3 = Label(lfroot, textvariable=label3, font=('Century_Gothic', 11)).place(x=100, y=159)
    # ----- Frame 2 --> checkbox 1
    fulldaterange = dynamicdayrange()
    startdaterange = StringVar()
    startdaterange.set(fulldaterange[1])
    enddaterange = StringVar()
    enddaterange.set(fulldaterange[2])
    global chbox1
    chbox1 = IntVar()
    c1 = Checkbutton(lfroot, text='Plan new Orders?', variable=chbox1, font=('Century_Gothic', 11),
                     onvalue=1, offvalue=0, command=service_disabler).place(x=425, y=228)
    # entry 1
    response99 = StringVar()
    global e1
    e1 = Entry(lfroot, textvariable=response99, width=9, state='disabled', justify=RIGHT, font=('Century_Gothic', 11))
    e1.place(x=425, y=260)
    response99.set(fulldaterange[2])
    evar1 = IntVar()
    # label 4
    l4 = Label(lfroot, text='New Order Plan Date', font=('Century_Gothic', 11)).place(x=505, y=258)
    # entry 2
    response98 = StringVar()
    global e2
    e2 = Entry(lfroot, textvariable=response98, width=9, state='disabled', justify=RIGHT, font=('Century_Gothic', 11))
    e2.place(x=425, y=287)
    response98.set('0.95')
    # label 5
    l5 = Label(lfroot, text='Target Utilization', font=('Century_Gothic', 11)).place(x=505, y=285)
    # entry 3
    response97 = StringVar()
    global e3
    e3 = Entry(lfroot, textvariable=response97, width=9, state='normal', justify=RIGHT, font=('Century_Gothic', 11))
    e3.place(x=425, y=314)
    response97.set('2000')
    # label 6
    l6 = Label(lfroot, text='Dunnage Buffer', font=('Century_Gothic', 11)).place(x=505, y=312)
    # entry 4
    response96 = StringVar()
    global erunname
    erunname = Entry(lfroot, textvariable=response96, width=15, state='normal', justify=CENTER,
                     font=('Century_Gothic', 11))
    erunname.place(x=643, y=26)
    # get current date to name directory output name
    runname = datetime.datetime.today().strftime("%Y-%m%d-%H%M")  # ex 2021-0210-2322
    response96.set(runname)
    # label 7
    labelrunname = Label(lfroot, text='Run Name', font=('Century_Gothic', 11)).place(x=562, y=26)
    # variable responses
    chbox1x = int(chbox1.get())
    response99x = str(response99.get())
    response98x = float(str(response98.get()))
    response97x = int(str(response97.get()))
    # side functions
    global cmirbtn
    cmirbtn = Button(lfroot, text='CMIR', height=bht, width=bwt, command=socmir_round_btn,
                     font=('Century_Gothic', 12), bg='#D8E0E4')
    cmirbtn.place(x=698, y=89)
    reqknit = Button(lfroot, text='rKnit', width=bwt, command=reqxlsxknitter,
                     font=('Century_Gothic', 12), bg='#D8E0E4', fg='#091F3F')
    reqknit.place(x=698, y=121)
    ifrknit = Button(lfroot, text='iKnit', width=bwt, command=xlsxknitter,
                     font=('Century_Gothic', 12), bg='#D8E0E4', fg='#091F3F')
    ifrknit.place(x=698, y=153)
    # ----- Frame 3
    mclogo = resource_path('logo-369x123.png')
    mclogo1 = Image.open(mclogo)
    mclogo2 = ImageTk.PhotoImage(mclogo1)
    logo = Label(image=mclogo2, highlightbackground='#FFFFFF', highlightcolor='#FFFFFF',
                 highlightthickness=0)
    logo.image = mclogo2
    logo.place(x=16, y=221, anchor='nw')
    # -----Frame 4 --> Fill existing deliveries
    global optbtn1
    optbtn1 = Button(lfroot, text='Fill', height=bht, width=bwt, command=load_filler_btn,
                     font=('Century_Gothic', 12), bg='#FFB000')
    optbtn1.place(x=425, y=90)
    global optlbl1
    optlbl1 = Label(lfroot, text='Fill existing Deliveries', font=('Century_Gothic', 11)).place(x=500, y=95)
    global optbtn2
    optbtn2 = Button(lfroot, text='Create', height=bht, width=bwt, command=del_planner_btn,
                     font=('Century_Gothic', 12), state=DISABLED)
    optbtn2.place(x=425, y=122)
    global optlbl2
    optlbl2 = Label(lfroot, text='Plan new Deliveries', font=('Century_Gothic', 11)).place(x=500, y=127)
    # Fill existing deliveries and create new ones
    global optbtn3
    optbtn3 = Button(lfroot, text='Both', height=bht, width=bwt, command=load_both_btn,
                     font=('Century_Gothic', 12), state=DISABLED)
    optbtn3.place(x=425, y=154)
    global optlbl3
    optlbl3 = Label(lfroot, text='Fill and plan Deliveries', font=('Century_Gothic', 11)).place(x=500, y=159)
    # -----Day Frame --> create labels for day range
    daylbl1 = Label(lfroot, text='Date Range', font=('Tuno', 12)).place(x=730, y=225, anchor='n')
    daylbl2 = Label(lfroot, textvariable=startdaterange, font=('Century_Gothic', 11),
                    ).place(x=730, y=280, anchor='n')
    daylbl3 = Label(lfroot, text='----- to -----', font=('Century_Gothic', 11),
                    ).place(x=730, y=300, anchor='n')
    daylbl4 = Label(lfroot, textvariable=enddaterange, font=('Century_Gothic', 11),
                    ).place(x=730, y=320, anchor='n')
    # ----- create window loop
    lfroot.mainloop()
    return


def ewm_filling_menu():
    # define variables
    global lwvrfilename
    global updrfilename
    global gatpfilename
    global mitfilename
    global lwvrfilenamex
    global updrfilenamex
    global gatpfilenamex
    global mitfilenamex
    global mskus_to_remove
    lwvrfilename = ''
    updrfilename = ''
    gatpfilename = ''
    mitfilename = ''
    lwvrfilenamex = ''
    updrfilenamex = ''
    gatpfilenamex = ''
    mitfilenamex = ''
    mskus_to_remove = ''
    lfht = 359  # golden rectangle ratio -> 1:1.61
    lfwt = 790  # golden rectangle ratio -> 1:1.61
    # ----- create widget variables
    border = 10
    bttnht = 5
    bttnwt = 60
    bht = 1  # button height
    bwt = 6  # button width
    # ----- create root window
    global lfroot
    lfroot = tk.Tk()
    # Gets the requested values of the height and width
    windowWidth = lfroot.winfo_reqwidth()
    windowHeight = lfroot.winfo_reqheight()
    # Gets both half the screen width/height and window width/height
    positionRight = int(lfroot.winfo_screenwidth() / 2 - windowWidth / 2)
    positionDown = int(lfroot.winfo_screenheight() / 2 - windowHeight / 2)
    positionRight = int(positionRight - (windowWidth * 1.5))
    positionDown = int(positionDown - (windowHeight / 2))
    # Positions the window in the center of the page
    lfroot.geometry("+{}+{}".format(positionRight, positionDown))
    # name window
    lfroot.title(apptitle + ' - EWM')
    mc_icon = resource_path('mc_icon.ico')
    lfroot.iconbitmap(mc_icon)
    # create gui canvas
    lfcanvas = tk.Canvas(lfroot, height=lfht, width=lfwt)
    lfcanvas.pack()
    # create gui frame
    lfframe = tk.Frame(lfroot, bg='#D8E0E4')
    lfframe.place(relx=0, rely=0, relwidth=1, relheight=1)
    # Frame 1 --> define stringvar labels
    global label1
    label1 = StringVar()
    label1.set('Select a Load Weight Filler Report')
    global label2
    label2 = StringVar()
    label2.set('Select a Requirements View Report')
    global label3
    label3 = StringVar()
    label3.set('Select an Inventory Flow Report')
    # Frame 5
    global label4
    label4 = StringVar()
    label4.set('Select a Requirements View Report')
    global label5
    label5 = StringVar()
    label5.set('Select an MIT Tool Report')
    global label6
    label6 = StringVar()
    label6.set('Select an Inventory Flow Report')
    # ----- Main Window frames and widgets
    finfo = Frame(lfroot, bd=0, height=45, width=225, highlightbackground='#091F3F',
                  highlightcolor='#D8E0E4', highlightthickness=1).place(x=15, y=15)
    fselect = Frame(lfroot, bd=0, height=130, width=375, highlightbackground='#091F3F',
                    highlightcolor='#1496FF', highlightthickness=1).place(x=15, y=74)
    fopts = Frame(lfroot, bd=0, height=130, width=260, highlightbackground='#091F3F',
                  highlightcolor='#091F3F', highlightthickness=1).place(x=405, y=74)
    flogo = Frame(lfroot, bd=0, height=130, width=375, highlightbackground='#091F3F',
                  highlightcolor='#091F3F', highlightthickness=1).place(x=15, y=219)
    fset = Frame(lfroot, bd=0, height=130, width=260, highlightbackground='#091F3F',
                 highlightcolor='#091F3F', highlightthickness=1).place(x=405, y=219)
    frun = Frame(lfroot, bd=0, height=45, width=225, highlightbackground='#091F3F',
                 highlightcolor='#091F3F', highlightthickness=1).place(x=555, y=15)
    lflabel1 = tk.Label(lfroot, text='Dash Filler', fg='#091F3F', bg='#D8E0E4',
                        font=('Tuno', 32)).place(x=270, y=5, anchor='nw')
    fday1 = Frame(lfroot, bd=0, height=40, width=100, highlightbackground='#091F3F',
                  highlightcolor='#091F3F', highlightthickness=1).place(x=680, y=219)
    fday2 = Frame(lfroot, bd=0, height=75, width=100, highlightbackground='#091F3F',
                  highlightcolor='#091F3F', highlightthickness=1).place(x=680, y=274)
    fcmir = Frame(lfroot, bd=0, height=130, width=100, highlightbackground='#091F3F',
                  highlightcolor='#091F3F', highlightthickness=1).place(x=680, y=74)
    # ----- Frame 0
    menu = tk.Button(lfroot, text='Menu', width=bwt, height=bht, bg='#1496FF',
                     font=('Century_Gothic', 12), command=service_menu_back).place(x=30, y=22, anchor='nw')
    mit = tk.Button(lfroot, text='MIT', width=bwt, height=bht, bg='#FFB000',
                    font=('Century_Gothic', 12), command=open_mit).place(x=95, y=22, anchor='nw')
    msku = tk.Button(lfroot, text='MSKU', width=bwt, height=bht, bg='#FF6912',
                     font=('Century_Gothic', 12), command=mskufilling_menu).place(x=160, y=22, anchor='nw')
    # knitter = tk.Button(lfroot, text='Knitter', width=bwt, height=bht, bg='#FFB000',
    #                     command=xlsxknitter, font=('Century_Gothic', 12)).place(x=160, y=22, anchor='nw')
    # ----- Frame 1 --> Loads
    lwvbtn = Button(lfroot, text='LWF', width=bwt, command=open_lwvr,
                    font=('Century_Gothic', 12), bg='#FFB000', fg='#091F3F').place(x=30, y=90)
    lwvlbl = Label(lfroot, textvariable=label1, font=('Century_Gothic', 11)).place(x=100, y=95)
    # Orders
    updbtn = Button(lfroot, text='REQ', width=bwt, command=open_updr,
                    font=('Century_Gothic', 12), bg='#FFB000', fg='#091F3F').place(x=30, y=122)
    updlbl = Label(lfroot, textvariable=label2, font=('Century_Gothic', 11)).place(x=100, y=127)
    # gATP
    atpbtn = Button(lfroot, text='IFR', width=bwt, command=open_gatp,
                    font=('Century_Gothic', 12), bg='#FFB000', fg='#091F3F').place(x=30, y=154)
    l3 = Label(lfroot, textvariable=label3, font=('Century_Gothic', 11)).place(x=100, y=159)
    # ----- Frame 2 --> checkbox 1
    # global chbox1
    # chbox1 = IntVar()
    # c1 = Checkbutton(lfroot, text='Plan new Orders?', variable=chbox1, font=('Century_Gothic', 11),
    #                  onvalue=1, offvalue=0, command=service_disabler).place(x=425, y=228)
    # entry 1
    response99 = StringVar()
    global e1
    e1 = Entry(lfroot, textvariable=response99, width=7, state='disabled', justify=RIGHT, font=('Century_Gothic', 11))
    e1.place(x=425, y=260)
    response99.set('100')
    evar1 = IntVar()
    # label 4
    l4 = Label(lfroot, text='Orders to create', font=('Century_Gothic', 11)).place(x=500, y=258)
    # entry 2
    response98 = StringVar()
    global e2
    e2 = Entry(lfroot, textvariable=response98, width=7, state='disabled', justify=RIGHT, font=('Century_Gothic', 11))
    e2.place(x=425, y=287)
    response98.set('1800')
    # label 5
    l5 = Label(lfroot, text='Cutoff Weight', font=('Century_Gothic', 11)).place(x=500, y=285)
    # entry 3
    response97 = StringVar()
    global e3
    e3 = Entry(lfroot, textvariable=response97, width=7, state='normal', justify=RIGHT, font=('Century_Gothic', 11))
    e3.place(x=425, y=314)
    response97.set('2000')
    # label 6
    l6 = Label(lfroot, text='Dunnage Buffer', font=('Century_Gothic', 11)).place(x=500, y=312)
    # entry 4
    response96 = StringVar()
    global erunname
    erunname = Entry(lfroot, textvariable=response96, width=15, state='normal', justify=CENTER,
                     font=('Century_Gothic', 11))
    erunname.place(x=643, y=26)
    # get current date to name directory output name
    runname = datetime.datetime.today().strftime("%Y-%m%d-%H%M")  # ex 2021-0210-2322
    response96.set(runname)
    # label 7
    labelrunname = Label(lfroot, text='Run Name', font=('Century_Gothic', 11)).place(x=562, y=26)
    # variable responses
    chbox1x = int(chbox1.get())
    response99x = int(str(response99.get()))
    response98x = float(str(response98.get()))
    response97x = int(str(response97.get()))
    # side functions
    global cmirbtn
    cmirbtn = Button(lfroot, text='CMIR', height=bht, width=bwt, command=socmir_round_btn,
                     font=('Century_Gothic', 12), bg='#D8E0E4')
    cmirbtn.place(x=698, y=89)
    reqknit = Button(lfroot, text='rKnit', width=bwt, command=reqxlsxknitter,
                     font=('Century_Gothic', 12), bg='#D8E0E4', fg='#091F3F')
    reqknit.place(x=698, y=121)
    ifrknit = Button(lfroot, text='iKnit', width=bwt, command=xlsxknitter,
                     font=('Century_Gothic', 12), bg='#D8E0E4', fg='#091F3F')
    ifrknit.place(x=698, y=153)
    # ----- Frame 3
    mclogo = resource_path('logo-369x123.png')
    mclogo1 = Image.open(mclogo)
    mclogo2 = ImageTk.PhotoImage(mclogo1)
    logo = Label(image=mclogo2, highlightbackground='#FFFFFF', highlightcolor='#FFFFFF',
                 highlightthickness=0)
    logo.image = mclogo2
    logo.place(x=16, y=221, anchor='nw')
    # -----Frame 4 --> Fill existing deliveries
    global optbtn1
    optbtn1 = Button(lfroot, text='Fill', height=bht, width=bwt, command=ewm_load_filler_btn,
                     font=('Century_Gothic', 12), bg='#FFB000')
    optbtn1.place(x=425, y=90)
    global optlbl1
    optlbl1 = Label(lfroot, text='Fill EWM Deliveries', font=('Century_Gothic', 11)).place(x=500, y=95)
    # global optbtn2
    # optbtn2 = Button(lfroot, text='Create', height=bht, width=bwt, command=onclick,
    #                  font=('Century_Gothic', 12), state=DISABLED)
    # optbtn2.place(x=425, y=122)
    # global optlbl2
    # optlbl2 = Label(lfroot, text='Plan new Deliveries', font=('Century_Gothic', 11)).place(x=500, y=126)
    # # Fill existing deliveries and create new ones
    # global optbtn3
    # optbtn3 = Button(lfroot, text='Both', height=bht, width=bwt, command=onclick,
    #                  font=('Century_Gothic', 12), state=DISABLED)  # command=load_both_btn,
    # optbtn3.place(x=425, y=154)
    # global optlbl3
    # optlbl3 = Label(lfroot, text='Fill and plan Deliveries', font=('Century_Gothic', 11)).place(x=500, y=159)
    # -----Day Frame --> calculate day range
    fulldaterange = ewm_dynamicdayrange()
    startdaterange = StringVar()
    startdaterange.set(fulldaterange[1])
    enddaterange = StringVar()
    enddaterange.set(fulldaterange[2])
    # create labels for day range
    daylbl1 = Label(lfroot, text='Date Range', font=('Tuno', 12)).place(x=730, y=225, anchor='n')
    daylbl2 = Label(lfroot, textvariable=startdaterange, font=('Century_Gothic', 11),
                    ).place(x=730, y=280, anchor='n')
    daylbl3 = Label(lfroot, text='----- to -----', font=('Century_Gothic', 11),
                    ).place(x=730, y=300, anchor='n')
    daylbl4 = Label(lfroot, textvariable=enddaterange, font=('Century_Gothic', 11),
                    ).place(x=730, y=320, anchor='n')
    # ----- create window loop
    lfroot.mainloop()
    return


def sto_filling_menu():
    # ----- main --> define variables
    global lwvrfilename
    global updrfilename
    global gatpfilename
    global mitfilename
    global lwvrfilenamex
    global updrfilenamex
    global gatpfilenamex
    global mitfilenamex
    global mskus_to_remove
    lwvrfilename = ''
    updrfilename = ''
    gatpfilename = ''
    mitfilename = ''
    lwvrfilenamex = ''
    updrfilenamex = ''
    gatpfilenamex = ''
    mitfilenamex = ''
    mskus_to_remove = ''
    lfht = 359  # golden rectangle ratio -> 1:1.61
    lfwt = 790  # golden rectangle ratio -> 1:1.61
    # ----- create widget variables
    border = 10
    bttnht = 5
    bttnwt = 60
    bht = 1  # button height
    bwt = 6  # button width
    # ----- create root window
    global lfroot
    lfroot = tk.Tk()
    # Gets the requested values of the height and width
    windowWidth = lfroot.winfo_reqwidth()
    windowHeight = lfroot.winfo_reqheight()
    # Gets both half the screen width/height and window width/height
    positionRight = int(lfroot.winfo_screenwidth() / 2 - windowWidth / 2)
    positionDown = int(lfroot.winfo_screenheight() / 2 - windowHeight / 2)
    positionRight = int(positionRight - (windowWidth * 1.5))
    positionDown = int(positionDown - (windowHeight / 2))
    # Positions the window in the center of the page.
    lfroot.geometry("+{}+{}".format(positionRight, positionDown))
    # name window
    lfroot.title(apptitle)
    mc_icon = resource_path('mc_icon.ico')
    lfroot.iconbitmap(mc_icon)
    # create gui canvas
    lfcanvas = tk.Canvas(lfroot, height=lfht, width=lfwt)
    lfcanvas.pack()
    # create gui frame
    lfframe = tk.Frame(lfroot, bg='#D8E0E4')
    lfframe.place(relx=0, rely=0, relwidth=1, relheight=1)
    # Frame 1 --> define stringvar labels
    fulldaterange = dynamicdayrange()
    startdaterange = StringVar()
    startdaterange.set(fulldaterange[1])
    enddaterange = StringVar()
    enddaterange.set(fulldaterange[2])
    global label1
    label1 = StringVar()
    label1.set('Select a Load Weight Filler Report')
    global label2
    label2 = StringVar()
    label2.set('Select a Requirements View Report')
    global label3
    label3 = StringVar()
    label3.set('Select an Inventory Flow Report')
    # Frame 5
    global label4
    label4 = StringVar()
    label4.set('Select a Requirements View Report')
    global label5
    label5 = StringVar()
    label5.set('Select an MIT Tool Report')
    global label6
    label6 = StringVar()
    label6.set('Select an Inventory Flow Report')
    # ----- Main Window frames and widgets
    finfo = Frame(lfroot, bd=0, height=45, width=225, highlightbackground='#091F3F',
                  highlightcolor='#D8E0E4', highlightthickness=1).place(x=15, y=15)
    fselect = Frame(lfroot, bd=0, height=130, width=375, highlightbackground='#091F3F',
                    highlightcolor='#1496FF', highlightthickness=1).place(x=15, y=74)
    fopts = Frame(lfroot, bd=0, height=130, width=260, highlightbackground='#091F3F',
                  highlightcolor='#091F3F', highlightthickness=1).place(x=405, y=74)
    flogo = Frame(lfroot, bd=0, height=130, width=375, highlightbackground='#091F3F',
                  highlightcolor='#091F3F', highlightthickness=1).place(x=15, y=219)
    fset = Frame(lfroot, bd=0, height=130, width=260, highlightbackground='#091F3F',
                 highlightcolor='#091F3F', highlightthickness=1).place(x=405, y=219)
    frun = Frame(lfroot, bd=0, height=45, width=225, highlightbackground='#091F3F',
                 highlightcolor='#091F3F', highlightthickness=1).place(x=555, y=15)
    lflabel1 = tk.Label(lfroot, text='Dash Filler', fg='#091F3F', bg='#D8E0E4',
                        font=('Tuno', 32)).place(x=270, y=5, anchor='nw')
    fday1 = Frame(lfroot, bd=0, height=40, width=100, highlightbackground='#091F3F',
                  highlightcolor='#091F3F', highlightthickness=1).place(x=680, y=219)
    fday2 = Frame(lfroot, bd=0, height=75, width=100, highlightbackground='#091F3F',
                  highlightcolor='#091F3F', highlightthickness=1).place(x=680, y=274)
    fcmir = Frame(lfroot, bd=0, height=130, width=100, highlightbackground='#091F3F',
                  highlightcolor='#091F3F', highlightthickness=1).place(x=680, y=74)

    # ----- Frame 0
    menu = tk.Button(lfroot, text='Menu', width=bwt, height=bht, bg='#1496FF',
                     font=('Century_Gothic', 12), command=service_menu_back).place(x=30, y=22, anchor='nw')
    mit = tk.Button(lfroot, text='MIT', width=bwt, height=bht, bg='#FFB000',
                    font=('Century_Gothic', 12), command=open_mit).place(x=95, y=22, anchor='nw')
    msku = tk.Button(lfroot, text='MSKU', width=bwt, height=bht, bg='#FF6912',
                     font=('Century_Gothic', 12), command=mskufilling_menu).place(x=160, y=22, anchor='nw')
    # ----- Frame 1 --> Loads
    lwvbtn = Button(lfroot, text='LWF', width=bwt, command=open_lwvr,
                    font=('Century_Gothic', 12), bg='#FFB000', fg='#091F3F').place(x=30, y=90)
    lwvlbl = Label(lfroot, textvariable=label1, font=('Century_Gothic', 11)).place(x=100, y=95)
    # Orders
    updbtn = Button(lfroot, text='REQ', width=bwt, command=open_updr,
                    font=('Century_Gothic', 12), bg='#FFB000', fg='#091F3F').place(x=30, y=122)
    updlbl = Label(lfroot, textvariable=label2, font=('Century_Gothic', 11)).place(x=100, y=127)
    # gATP
    atpbtn = Button(lfroot, text='IFR', width=bwt, command=open_gatp,
                    font=('Century_Gothic', 12), bg='#FFB000', fg='#091F3F').place(x=30, y=154)
    l3 = Label(lfroot, textvariable=label3, font=('Century_Gothic', 11)).place(x=100, y=159)
    # ----- Frame 2 --> checkbox 1
    global chbox1
    chbox1 = IntVar()
    c1 = Checkbutton(lfroot, text='Plan new STOs?', variable=chbox1, font=('Century_Gothic', 11),
                     onvalue=1, offvalue=0, command=service_disabler).place(x=425, y=228)
    # entry 1
    plandate = StringVar()
    global e1
    e1 = Entry(lfroot, textvariable=plandate, width=9, state='disabled', justify=RIGHT, font=('Century_Gothic', 11))
    e1.place(x=425, y=260)
    plandate.set(fulldaterange[2])
    evar1 = IntVar()
    # label 4
    l4 = Label(lfroot, text='New STO Plan Date', font=('Century_Gothic', 11)).place(x=505, y=258)
    # entry 2
    response98 = StringVar()
    global e2
    e2 = Entry(lfroot, textvariable=response98, width=9, state='disabled', justify=RIGHT, font=('Century_Gothic', 11))
    e2.place(x=425, y=287)
    response98.set('0.95')
    # label 5
    l5 = Label(lfroot, text='Target Utilization', font=('Century_Gothic', 11)).place(x=505, y=285)
    # entry 3
    response97 = StringVar()
    global e3
    e3 = Entry(lfroot, textvariable=response97, width=9, state='normal', justify=RIGHT, font=('Century_Gothic', 11))
    e3.place(x=425, y=314)
    response97.set('2000')
    # label 6
    l6 = Label(lfroot, text='Dunnage Buffer', font=('Century_Gothic', 11)).place(x=505, y=312)
    # entry 4
    response96 = StringVar()
    global erunname
    erunname = Entry(lfroot, textvariable=response96, width=15, state='normal', justify=CENTER,
                     font=('Century_Gothic', 11))
    erunname.place(x=643, y=26)
    # get current date to name directory output name
    runname = datetime.datetime.today().strftime("%Y-%m%d-%H%M")  # ex 2021-0210-2322
    response96.set(runname)
    # label 7
    labelrunname = Label(lfroot, text='Run Name', font=('Century_Gothic', 11)).place(x=562, y=26)
    # variable responses
    chbox1x = int(chbox1.get())
    response99x = str(plandate.get())
    response98x = float(str(response98.get()))
    response97x = int(str(response97.get()))
    # side functions
    global cmirbtn
    cmirbtn = Button(lfroot, text='CMIR', height=bht, width=bwt, command=socmir_round_btn,
                     font=('Century_Gothic', 12), bg='#D8E0E4')
    cmirbtn.place(x=698, y=89)
    reqknit = Button(lfroot, text='rKnit', width=bwt, command=reqxlsxknitter,
                     font=('Century_Gothic', 12), bg='#D8E0E4', fg='#091F3F')
    reqknit.place(x=698, y=121)
    ifrknit = Button(lfroot, text='iKnit', width=bwt, command=xlsxknitter,
                     font=('Century_Gothic', 12), bg='#D8E0E4', fg='#091F3F')
    ifrknit.place(x=698, y=153)
    # ----- Frame 3
    mclogo = resource_path('logo-369x123.png')
    mclogo1 = Image.open(mclogo)
    mclogo2 = ImageTk.PhotoImage(mclogo1)
    logo = Label(image=mclogo2, highlightbackground='#FFFFFF', highlightcolor='#FFFFFF',
                 highlightthickness=0)
    logo.image = mclogo2
    logo.place(x=16, y=221, anchor='nw')
    # -----Frame 4 --> Fill existing deliveries
    global optbtn1
    optbtn1 = Button(lfroot, text='Fill', height=bht, width=bwt, command=sto_load_filler_btn,
                     font=('Century_Gothic', 12), bg='#FFB000')
    optbtn1.place(x=425, y=90)
    global optlbl1
    optlbl1 = Label(lfroot, text='Fill existing STOs', font=('Century_Gothic', 11)).place(x=500, y=95)
    global optbtn2
    optbtn2 = Button(lfroot, text='Create', height=bht, width=bwt, command=sto_planner_btn,
                     font=('Century_Gothic', 12), state=DISABLED)
    optbtn2.place(x=425, y=122)
    global optlbl2
    optlbl2 = Label(lfroot, text='Plan new STOs', font=('Century_Gothic', 11)).place(x=500, y=127)
    # Fill existing deliveries and create new ones
    global optbtn3
    optbtn3 = Button(lfroot, text='Both', height=bht, width=bwt, command=sto_load_both_btn,
                     font=('Century_Gothic', 12), state=DISABLED)
    optbtn3.place(x=425, y=154)
    global optlbl3
    optlbl3 = Label(lfroot, text='Fill and plan STOs', font=('Century_Gothic', 11)).place(x=500, y=159)
    # -----Day Frame --> create labels for day range
    daylbl1 = Label(lfroot, text='Date Range', font=('Tuno', 12)).place(x=730, y=225, anchor='n')
    daylbl2 = Label(lfroot, textvariable=startdaterange, font=('Century_Gothic', 11),
                    ).place(x=730, y=280, anchor='n')
    daylbl3 = Label(lfroot, text='----- to -----', font=('Century_Gothic', 11),
                    ).place(x=730, y=300, anchor='n')
    daylbl4 = Label(lfroot, textvariable=enddaterange, font=('Century_Gothic', 11),
                    ).place(x=730, y=320, anchor='n')
    # ----- create window loop
    lfroot.mainloop()
    return


# service_menu()
main_menu()
